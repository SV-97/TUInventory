#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{multicol}
\end_preamble
\use_default_options true
\begin_modules
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language ngerman
\language_package auto
\inputencoding iso8859-2
\fontencoding global
\font_roman "default" "default"
\font_sans "helvet" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex8
\index_command default
\float_placement H
\paperfontsize 11
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\rightmargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily\small},language=Python,breaklines=true,prebreak={\mbox{{$\textbackslash$}\space}},postbreak={\mbox{{$$}\space}}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author 274824651 "sv-97"
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
renewcommand{
\backslash
rmdefault}{phv} % font to Arial
\end_layout

\begin_layout Plain Layout

%
\backslash
renewcommand{
\backslash
sfdefault}{phv} % font to Arial
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{gobble} % disable page numbering
\end_layout

\end_inset


\end_layout

\begin_layout Title
TUI - Test- und Integrationssystem für SCADA-Software
\end_layout

\begin_layout Author
von Stefan Volz & Yannis Köhler
\end_layout

\begin_layout Standard
\begin_inset VSpace 40pheight%
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Bilder/Logo.png
	scale 60

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Graphics
	filename Bilder/Schullogo.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Abkürzungsverzeichnis
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="28" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abk.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beschreibung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AMQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic Message Queue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Application Programming Interface
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CLI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Command Line Interface
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Digital Input
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DLR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dynamic Language Runtime
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Digital Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ERD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity-Relationship-Diagramm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ERM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity-Relationship-Modell
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HMAC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Keyed-Hash Message Authentication Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IPC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Industrie-PC
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Just-in-time  (bei Bedarf)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JRE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java Runtime Environment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JVM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java Virtual Machine
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kalenderwoche
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Computer Vision
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OAEP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Optimal Asymmetric Encryption Padding
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ORM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Object Relational Mapper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PBKDF2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Password-Based Key Derivation Function 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PEP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Python Enhancement Proposal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PKCS #1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Public-Key Cryptography Standards First Family
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PSF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Python Software Foundation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SCADA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Supervisory Control and Data Acquisition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Secure Hash Algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stefan Volz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
User Interface
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Virtual Machine / Virtuelle Maschine
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
YK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yannis Köhler
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Markierungsschema
\end_layout

\begin_layout Standard
Zur Markierung, welcher Projektpartner welche Teile verfasst hat, werden
 Tags als Randnotizen im Inhaltsverzeichnis und an Überschriften genutzt.
 Dabei gilt, dass alle einem getaggten Abschnitt hierarchisch untergeordneten
 Abschnitte das übergeordnete Tag tragen, sofern sie nicht selbst eines
 besitzen.
 Der tatsächliche Verfasser ist über die Initialen im Tag codiert (Volle
 Namen im Inhaltsverzeichnis).
 Ein mit 
\emph on
&&
\emph default
 getaggter Abschnitt wurde kollaborativ vom ganzen Projektteam erstellt.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic} % enable page numbering
\end_layout

\end_inset


\end_layout

\begin_layout Part
Einführung
\begin_inset Marginal
status open

\begin_layout Plain Layout
[&&]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sämtliche Diagramme, Bilder, etc.
 sind, sofern nicht anders angegeben, selbst erstellt.
 Programmlistings wurden teils notwendigerweise implizit mittels 
\begin_inset Quotes gld
\end_inset


\backslash

\begin_inset Quotes grd
\end_inset

 umgebrochen.
 Dies ist zwar valide Python 3 Syntax, jedoch nicht in jedem Fall konform
 zu gängigen Format-Konventionen.
\end_layout

\begin_layout Section
Die Firma Padcon
\end_layout

\begin_layout Standard
Die Firma Padcon GmbH, ein Tochterunternehmen des deutschen Netzbetreibers
 RWE, ist ein weltweit agierendes IT-Unternehmen mit Sitz in Kitzingen.
 Zu ihren Produkten gehören Systeme zur Überwachung von Groß-Photovoltaikanlagen.
 Diese fallen in die Kategorie der SCADA-Systeme.
 Besonders nennenswert ist der „Pavagada Solar Park“ in Indien, welcher,
 nach Bauabschluss, mit knapp 2GW die aktuell größte Photovoltaikanlage
 der Welt darstellt.
\end_layout

\begin_layout Section
Aufgabenstellung
\end_layout

\begin_layout Standard
Für die Firma Padcon GmbH soll ein Test- und Integrationssystem erstellt
 werden.
 Dies umfasst die Dimensionierung und Installation von vier sogenannten
 Testplätzen in einem dafür vorgesehenen Raum.
 Hierfür muss auch eine neue Unterverteilung gebaut werden.
 An den Testplätzen wird man verschiedene Hardware wie IPC‘s, Router, Switches,
 etc.
 testen können.
 Ebenfalls sollen neue Versionen der firmeneigenen SCADA-Software, welche
 die Photovoltaik-Anlagen überwacht und Daten ausliest/aufzeichnet, getestet
 werden können, bevor diese an den Kunden ausgeliefert werden.
 Desweiteren soll eine Inventarsoftware erstellt werden, welche ein Einscannen
 von Barcodes ermöglicht und somit eine schnelle Zuordnung von Geräten zu
 Testplatz und zugehörigem Verantwortlichen zulässt.
 [sv]
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Part
Test- und Integrationsraum
\begin_inset Marginal
status open

\begin_layout Plain Layout
[yk]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Abschnitt 1 Raum
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Part
TUInventory
\begin_inset Marginal
status open

\begin_layout Plain Layout
[sv]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Begriffsdefinitionen
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="middle" width="50page%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Begriff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Definition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Duck-Typing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Der Typ einer Instanz wird dadurch beschrieben/festgelegt welche Member
 sie besitzt  (Von eng.: 
\begin_inset Quotes eld
\end_inset

If it looks like a duck, swims like a duck, and quacks like a duck, then
 it probably is a duck.
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dynamisch Typisiert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typüberprüfung zur Laufzeit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Frame
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Einzelnes Bild einer Videosequenz, hier synonym für Bildmatrix eingesetzt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function Decorator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ist Funktionsdefinition mit @decorator vorgestellt - Stellt im Prinzip eine
 Definition der Funktion f dar, der ein f = decorator (f) nachgestellt ist.
 Hierbei wird eine Funktion i.d.R.
 um weitere Funktionalität  (z.B.
 ein Cache oder die Möglichkeit Vektoren zu verarbeiten) erweitert
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Immutabel / immutable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unveränderbar
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kontext-Manager / Context Manager
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Klasse, die __enter__ und __exit__ implementiert.
 Erlaubt es Objekte auch im Fehlerfall sauber zu deinitialisieren, bzw.
 zu schließen  (entspricht einem try-finally-Block).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lazy evaluation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Die Auswertung eines Ausdrucks erfolgt nur soweit sie gerade nötig ist.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Magic Method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eine i.d.R.
 implizit aufgerufene Methode, welche einer Klasse besondere Fähigkeiten
 verleiht
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "S. 369"
key "Python3"
literal "true"

\end_inset


\end_layout

\end_inset

.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mutabel / mutable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Veränderbar
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mutex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gegenseitig ausschließend  (von engl.
 mutual exclusion)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ORM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Programmiertechnik um Daten zwischen inkompatiblen Typsystemen  (hier Datenbank
 in SQLite3 und Python) zu konvertieren und somit eine virtuelle Objektdatenbank
 zu schaffen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pythonic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Idiomatisch im Bezug auf Python
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Race-Condition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Im Falle einer Race-Condition ist das Ergebnis einer Operation nicht determinist
isch, es wird beeinflusst durch äußere Gegebenheiten wie z.B.
 Prozessorlast
\end_layout

\begin_layout Plain Layout
Der Name stammt von der Vorstellung, dass Signale wettlaufen um die Ausgabe
 als erstes zu beeinflussen
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "24.12.18 - 01:25 Uhr"
key "Wiki_RaceCondition"
literal "false"

\end_inset


\end_layout

\end_inset

.
 Probleme einer Race-Condition sind beispielsweise, dass sie oftmals verschwinde
t wenn das Programm mittels Debugger betrachtet wird.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zufällige Zeichenfolge die in der Kryptografie u.A.
 bei Hash-Funktionen eingesetzt wird um die Entropie der Eingabe zu erhöhen.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Singleton
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ein Singleton ist ein Entwurfsmuster bei dem sichergestellt ist, dass nur
 eine einzige Instanz einer Klasse existiert  (z.B.
 in Python 
\emph on
None
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 (dt.: Faden, Strang) Threads sind im Grunde genommen leichtgewichtige Prozesse
  (Ein Prozess kann mehrere Threads besitzen).
 In CPython  (erläutert in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Python-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) ist der GIL  (Global Interpreter Lock) zu beachten: Threads steigern hier
 nicht die Performance!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thread-Safe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 (dt.: Threadsicherheit) Mehrere Threads können gleichzeitig auf eine Komponente
 zugreifen ohne sich gegenseitig zu behindern oder race-conditions auszulösen
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Einführung und Problemanalyse
\end_layout

\begin_layout Standard
Um ein flüssiges Arbeiten mit dem Testraum zu gewährleisten, ist ein Inventarsys
tem erforderlich.
 Dieses System ist grundsätzlich aus drei Teilen aufgebaut:
\end_layout

\begin_layout Enumerate
Ein Codierungssystem zum eindeutigen Markieren von Geräten
\end_layout

\begin_layout Enumerate
Eine grafische Desktopanwendung, über die Geräte, bzw.
 eine Datenbank verwaltet werden können
\end_layout

\begin_layout Enumerate
Eine Kommandozeilen-Schnittstelle um spezielle Funktionen extern verfügbar
 zu machen
\end_layout

\begin_layout Subsection
Codierungssystem
\end_layout

\begin_layout Standard
An das Codierungssystem werden folgende Anforderungen gestellt:
\end_layout

\begin_layout Itemize
Problemlos an einer Vielzahl von Geräten zu befestigen (keine komplexe Befestigu
ng wie z.B.
 NFC-Tag)
\end_layout

\begin_layout Itemize
Nicht-properitäres System, um auch von anderen Geräten/Anwendungen verwertet
 werden zu können
\end_layout

\begin_layout Itemize
Einfache Auswertung und Codierung von selbst definierten Daten
\end_layout

\begin_layout Standard
Generell gibt es einige Möglichkeiten zur Codierung, welche mehr oder weniger
 gut für diesen Use Case geeignet sind:
\end_layout

\begin_layout Description
RFID Eher unpraktisch in Sachen nachträglicher Anbringung an beliebigen
 Geräten.
\end_layout

\begin_layout Description
EAN-Code EAN-Codes sind auf vielen Geräten bereits vorhanden, was sie zu
 einer attraktiven Wahl macht.
 Diese bereits vorhandenen Codes sind jedoch nicht für jedes Gerät eindeutig.
 Tatsächlich sind sie eher hinderlich, da beim Anbringen eines eigenen Codes
 Verwechslungsgefahr besteht.
\end_layout

\begin_layout Description
QR-Code QR-Codes sind sehr uneingeschränkt in Sachen Anbringung, können
 beliebige Daten halten und da sie optisch ausgewertet werden können, kann
 man sie mit jedem modernen Gerät wie einem Smartphone oder einem PC mit
 Kamera einfach auswerten.
\end_layout

\begin_layout Standard
Die Wahl fiel daher auf QR-Codes.
\end_layout

\begin_layout Subsection
Desktopanwendung und Kommandozeilen-Schnittstelle
\end_layout

\begin_layout Standard
Bei der Umsetzung der Desktopanwendung und der Kommandozeilen-Schnittstelle,
 die letzen Endes auf dem selben Softwarestack aufbauen sollen, stellt sich
 nach einigen grundlegenden Überlegungen die Frage der gewählten Programmierspra
che.
\end_layout

\begin_layout Standard
Einige Anforderungen sind:
\end_layout

\begin_layout Itemize
Lauffähigkeit auf mehrere Plattformen
\end_layout

\begin_layout Itemize
Wartung/Weiterentwicklung durch Padcon möglich
\end_layout

\begin_layout Standard
Hierbei gab es grundsätzlich drei Sprachen, die ernsthaft Betracht gezogen
 wurden (entweder für das ganze Projekt oder um einzelne Funktionalität
 zu implementieren):
\end_layout

\begin_layout Description
Java Da die Kraftwerksüberwachungssoftware größtenteils in Java geschrieben
 ist und dementsprechend viele Java-Programmierer bei Padcon zur Verfügung
 stehen, wäre Java eine attraktive Sprache.
 Auch die C#-ähnliche Syntax spricht dafür.
\end_layout

\begin_layout Description
C# Da C# bereits aus der Techniker-Ausbildung bekannt ist, wäre es eine
 denkbare Lösung.
 Jedoch ist C# immernoch nur bedingt Cross-Plattform
\begin_inset Foot
status open

\begin_layout Plain Layout
Mit dem Mono-Framework besteht grundsätzlich die Möglichkeit, C# Anwendungen
 für Linux zu entwickeln
\end_layout

\end_inset

 fähig.
 Eine Weiterentwicklung durch Padcon ist bedingt möglich, so ist grundlegende
 Syntax von C# ähnlich der von Java.
\end_layout

\begin_layout Description
Python Python ist eine grundlegend andere Sprache als Java und C#
\begin_inset Foot
status open

\begin_layout Plain Layout
Mehr dazu im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Python-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset

 und attraktiv, da es eine sehr schnelle Entwicklung ermöglicht.
 Desweiteren ist es bei praktisch allen Linux Distributionen vorinstalliert
 und bietet eine Vielzahl an Möglichkeiten um plattformübergreifende Anwendungen
 zu entwickeln.
\end_layout

\begin_layout Standard
Java wurde schnell verworfen, da es im Zeitraum des Projektes unrealistisch
 ist, die Anwendung in Java zu entwickeln und dabei idiomatischen, guten
 Code zu produzieren.
 C# wurde ebenfalls für ungeeignet befunden, da mit Problemen mit Linux
 gerechnet wurde.
 Außerdem liegt auch bei C#, ein eher langsamer Entwicklungsprozess vor.
 Der Vorteil der besseren Performance von C# und Java gegenüber CPython
 (der Standartimplementierung von Python, andere Implementierungen bieten
 vergleichbare Performance zu C#), ist hier eher irrelevant da die Anwendung
 aufgrund der grafischen Oberfläche ohnehin die meiste Zeit 
\begin_inset Quotes gld
\end_inset

idle
\begin_inset Quotes grd
\end_inset

 ist
\begin_inset Foot
status open

\begin_layout Plain Layout
Sicher wäre die Implementierung auch mit C++, Rust oder einer Vielzahl anderer
 Sprachen möglich gewesen, jedoch liegen in den meisten Fällen die gleichen
 
\begin_inset Quotes gld
\end_inset

Probleme
\begin_inset Quotes gld
\end_inset

 wie bei C# und Java vor: es würde sich einfach nicht lohnen eine performantere
 Sprache auf Kosten der Entwicklungszeit zu nutzen.
 Sollte zu einem späteren Zeitpunkt eine Erweiterung nötig sein, bei der
 sich herausstellt, dass die Geschwindigkeit von Python ein Flaschenhals
 ist, so lässt sich dieses performancekritische Modul in einer maschinennahen
 Sprache wie C oder Rust entwickeln und problemlos einbinden (oder man nutzt
 eine der alternativen Python Implementierungen welche in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Python-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 erläutert werden).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Python bietet desweiteren exzellente Interoperabilität mit C und kann auf
 viele große Frameworks aus den Bereichen C/C++ zurückgreifen (z.B.
 Qt und OpenCV).
 Der Pflege der Software durch Padcon steht auch bei Python nichts im Wege,
 da,
\end_layout

\begin_layout Enumerate
sich der Code größtenteils wie Pseudocode oder ein englischer Satz liest.
\end_layout

\begin_layout Enumerate
die Auszubildenen im Bereich Anwendungsentwicklung in Zukunft auch Python
 lernen.
\end_layout

\begin_layout Standard
Aufgrund dieser Punkte fiel die Wahl der Sprache auf Python.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Python-3"

\end_inset

Python 3
\end_layout

\begin_layout Standard
Bei Python 3 handelt es sich um eine universell einsetzbare, plattformübergreife
nde, dynamisch typisierte Hochsprache, welche in verschiedensten Implementierung
en als Open Source Projekt entwickelt wird.
 Ursprünglich wurde sie von Guido van Rossum 1991 mit dem Ziel entwickelt,
 eine möglichst lesbare und dennoch mächtige Programmiersprache zu schaffen.
 Auf der Website der PSF steht dazu: 
\begin_inset Quotes eld
\end_inset

Python is a programming language that lets you work quickly and integrate
 systems more effectively.
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 16:32 Uhr"
key "PSF"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Standardimplementierung CPython wird der Quellcode zuerst in einen
 Bytecode kompiliert, welcher dann von einer in C geschriebenen VM interpretiert
 wird.
 Andere bekannte Implementierungen sind z.B.
 PyPy  (Interpreter in RPython, Vorteil: sehr viel schneller als CPython,
 JIT-Compiler), Jython  (Ausführung mittels JVM, Vorteil: Interoperabilität
 mit JRE) oder IronPython  (Ausführung mittels DLR - also .NET, Vorteil:
 Interoperabilität mit .NET bzw.
 der CLI
\begin_inset Foot
status open

\begin_layout Plain Layout
Common Language Infrastructure
\end_layout

\end_inset

 und Integration in Visual Studio).
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 17:08 Uhr"
key "PyInterps"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle Ausführungen dieser Arbeit beziehen sich, sofern nicht anders angegeben,
 auf CPython in Version 3.7.
\end_layout

\begin_layout Subsection
Funktionen und Methoden in Python
\end_layout

\begin_layout Standard
Eine Besonderheit Pythons ist, dass alles, sei es Klasse, Instanz oder Funktion,
 ein Objekt ist
\begin_inset Foot
status open

\begin_layout Plain Layout
Selbst der Code welcher ausgeführt wird, ist ein, über den 
\emph on
__code__
\emph default
 Member erreichbares Objekt
\end_layout

\end_inset

.
 Dies bringt eine extreme Flexibilität mit sich.
\end_layout

\begin_layout Standard
Die Definitionen der Begriffe 
\emph on
Funktion
\emph default
 und 
\emph on
Methode
\emph default
 sind in Python anders als man es eventuell aus anderen Programmiersprachen
 kennt, daher seien sie hier kurz erläutert
\begin_inset Foot
status open

\begin_layout Plain Layout
Neben den 
\emph on
bound methods 
\emph default
gab es außerdem noch die sogenannten 
\emph on
unbound methods
\emph default
, die einer Methode entsprechen, welche ursprünglich zu einer Klasse gehört
 hat und somit eine Instanz dieser als ersten Parameter erwartet 
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 17:24 Uhr"
key "PythonDocDescriptorGuide"
literal "true"

\end_inset

, allerdings von der Klasse losgelöst wurde.
 Jedoch wurde dieses Konzept mit Python 3.0 verworfen; was früher eine 
\emph on
unbound method
\emph default
 war, ist nun ebenfalls eine 
\emph on
function 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 17:23 Uhr"
key "PythonDocWhatsNewPython3"
literal "true"

\end_inset


\emph on
.

\emph default
 
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kein decorator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@classmethod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@staticmethod
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Klasse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bound method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instanz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bound method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bound method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Neben Methoden und Funktionen ist auch auch möglich andere Objekte in Python
 aufrufbar zu machen, hierzu müssen sie die 
\emph on
magic method
\emph default
 
\emph on
__call__
\emph default
 implementieren.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/Funktionstypen.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die verschiedenen Funktionstypen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Formatierung
\end_layout

\begin_layout Standard
Ein Grundsatz der Quellcodeformatierung ist, dass der Code wesentlich öfter
 gelesen als geschrieben wird.
 Dementsprechend sollte hier mit großer Vorsicht und einer gut durchdachten
 Systematik vorgegangen werden.
 In Python gibt es als grundlegende Quelle, wie man seinen Code gut lesbar
 und idiomatisch schreibt und formatiert z.B.
 das 
\begin_inset Quotes eld
\end_inset

Zen of Python
\begin_inset Quotes erd
\end_inset

, welches in Python über 
\emph on
import this
\emph default
 eingesehen werden kann  (und als PEP 20 zu finden ist), oder aber die Python
 Enhancement Proposals PEP 8 und PEP 254.
\end_layout

\begin_layout Standard
PEP 8 trägt hier den Titel 
\begin_inset Quotes eld
\end_inset

Style Guide for Python Code
\begin_inset Quotes erd
\end_inset

 und umfasst alle Formatfragen von generellem Codelayout über Kommentare
 bis hin zu Namensgebungskonventionen
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fn:Fußnote"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 16:17 Uhr"
key "PEP8"
literal "false"

\end_inset


\end_layout

\end_inset

.
 PEP 257 hingegen beschäftigt sich mit den sogenannten Docstrings und deren
 Format 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 16:17 Uhr"
key "PEP257"
literal "false"

\end_inset


\end_layout

\end_inset

.
 Docstrings sind eine Form von Inline-Dokumentation, die z.B.
 die Schnittstelle und Funktion einer Methode beschreibt.
 Sie werden vom Python-Interpreter berücksichtigt und sind dann unter dem
 Magic Member 
\emph on
__doc__
\emph default
 zu finden.
 Über Docstrings könnte man aus dem Quellcode auch automatisch die Dokumentation
 generieren lassen, dies ist in unserem Fall jedoch nicht gewünscht, da
 die Dokumentation im Rahmen dieser Arbeit stattfindet  (im Anhang sind
 sie dennoch zu finden  ({modulname}.html)).
 Als weitere Referenz für das genutzte Format galten ein von Google veröffentlic
htes Dokument
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 17:36 Uhr"
key "GoogleStyleGuide"
literal "false"

\end_inset


\end_layout

\end_inset

, sowie der Talk 
\begin_inset Quotes eld
\end_inset

Beyond PEP 8 -- Best practices for beautiful intelligible code
\begin_inset Quotes erd
\end_inset

 von Raymond Hettinger, einem der Core Developer von CPython
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 17:40 Uhr"
key "BeyondPEP8"
literal "false"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Abschließend ist es jedoch ratsam, bei all diesen Formatforschriften nochmal
 Bezug auf den Anfang von PEP 8 zu nehmen: 
\begin_inset Quotes eld
\end_inset

A Foolish Consistency is the Hobgoblin of Little Minds
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Siehe Fußnote 
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:Fußnote"
plural "false"
caps "false"
noprefix "false"

\end_inset

  (PEP8)
\end_layout

\end_inset

 - man sollte also wissen, wann es die bessere Entscheidung ist mit den
 Vorschriften zu brechen.
\end_layout

\begin_layout Subsection
Vorwort und Übersicht über die Anwendung
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes gld
\end_inset

All computers are now parallel...
 Parallel programming 
\emph on
is
\emph default
 programming.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
- Michael McCool
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after ", S. 1"
key "Rust"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Wie die meisten modernen Anwendungen, setzt auch TUInventory an vielen Stellen
 auf Multithreading.
 Daher sei hier eine Grafik vorangestellt, die Kontroll-  (solider Pfeil)
 und Informationsfluss  (gestrichelter Pfeil) visualisiert:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Thread-Übersicht.png
	width 70page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Übersicht über Verhältnisse von Threads zueinander
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Desweiteren sei eine Übersicht über alle Module und deren Klassen, sowie
 Top-Level-Functions und Module-Level-Instanzen gegeben  (siehe hierzu auch
 die automatisch generierte Dokumentation im Anhang):
\end_layout

\begin_layout Description
barcodereader.py
\end_layout

\begin_deeper
\begin_layout Description
VideoStream class, thread
\end_layout

\begin_layout Description
LazyVideoStream class, thread
\end_layout

\begin_layout Description
Camera class
\end_layout

\end_deeper
\begin_layout Description
classes.py
\end_layout

\begin_deeper
\begin_layout Description
BigInt class
\end_layout

\begin_layout Description
setup_context_session method
\end_layout

\begin_deeper
\begin_layout Description
ContextSession class
\end_layout

\end_deeper
\begin_layout Description
Producer class
\end_layout

\begin_layout Description
Article class
\end_layout

\begin_layout Description
Device class
\end_layout

\begin_layout Description
PhoneNumber class
\end_layout

\begin_deeper
\begin_layout Description
NoNumberFoundWarning class
\end_layout

\end_deeper
\begin_layout Description
Location class
\end_layout

\begin_layout Description
User class
\end_layout

\begin_layout Description
Responsibility class
\end_layout

\begin_layout Description
Timeout class, thread
\end_layout

\begin_layout Description
VideoStreamUISync class, thread
\end_layout

\end_deeper
\begin_layout Description
cli
\end_layout

\begin_deeper
\begin_layout Description
cli_get_barcode.py
\end_layout

\end_deeper
\begin_layout Description
keys.py
\end_layout

\begin_deeper
\begin_layout Description
generate_key method
\end_layout

\begin_layout Description
read_keys method
\end_layout

\end_deeper
\begin_layout Description
logger.py
\end_layout

\begin_deeper
\begin_layout Description
logger RootLogger instance
\end_layout

\end_deeper
\begin_layout Description
main.py
\end_layout

\begin_deeper
\begin_layout Description
main method
\end_layout

\end_deeper
\begin_layout Description
qr_generator.py
\end_layout

\begin_deeper
\begin_layout Description
generate_qr method
\end_layout

\end_deeper
\begin_layout Description
slots.py
\end_layout

\begin_deeper
\begin_layout Description
save_to_db method
\end_layout

\begin_layout Description
update_user_dependant method
\end_layout

\begin_layout Description
create_user method
\end_layout

\begin_layout Description
create_admin method
\end_layout

\begin_layout Description
login method
\end_layout

\begin_layout Description
logout method
\end_layout

\begin_layout Description
create_device method
\end_layout

\begin_layout Description
create_location method
\end_layout

\begin_layout Description
create_producer method
\end_layout

\begin_layout Description
generate_password method
\end_layout

\begin_layout Description
reset_password method
\end_layout

\begin_layout Description
reset_admin_password method
\end_layout

\end_deeper
\begin_layout Description
ui.py
\end_layout

\begin_deeper
\begin_layout Description
MainDialog class
\end_layout

\begin_layout Description
LoginDialog class
\end_layout

\end_deeper
\begin_layout Description
utils.py
\end_layout

\begin_deeper
\begin_layout Description
absolute_path method
\end_layout

\begin_layout Description
_ParallelPrint class, thread
\end_layout

\begin_layout Description
parallel_print put method of _ParallelPrint instance
\end_layout

\end_deeper
\begin_layout Section
Command Line Interface
\end_layout

\begin_layout Standard
Im CLI sollte ursprünglich der volle Umfang des Barcodereaders umgesetzt
 werden, dies wurde auch so durchgeführt.
 Jedoch stellte sich heraus, dass lediglich das Extrahieren eines Barcodes
 aus einem gegebenen Bild nötig war.
 Mit Blick auf die Größe des CLI wurde daher die restliche Funktionalität
 entfernt.
\end_layout

\begin_layout Standard
Das CLI setzt intern auf Pythons eingebautes Modul 
\emph on
argparse
\emph default
, bzw.
 dessen 
\emph on
ArgumentParser
\emph default
.
 Das Interface zeigt sich über Kommandozeilenparameter 
\emph on
-h
\emph default
 dabei wie folgt:
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/cli_help.sh"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schnittstellenhilfe von cli_get_barcode.py
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Über 
\emph on
-h
\emph default
 kann also wie oben dargestellt eine Schnittstellenbeschreibung angezeigt
 werden.
 
\emph on
-i
\emph default
 ist der Parameter, über welchen der Pfad zu einem Bild übergeben wird.
 Aus diesem Bild wird der Barcode ausgelesen und zurückgegeben.
 In der Regel wird lediglich der Inhalt eines Codes benötigt, jedoch kann
 es mitunter nützlich sein, mehr Details (wie z.B.
 um welche Art Code es sich handelt) zu erhalten.
 Daher existiert das Flag 
\emph on
-d
\emph default
, welches es ermöglicht alle intern verfügbaren Informationen über das Bild,
 bzw.
 die darin enthaltenen Codes wiederzugeben.
 Hierüber ist es außerdem möglich mehrere Codes aus einem Bild zu extrahieren.
\end_layout

\begin_layout Standard
Der letzte Parameter ist 
\emph on
-tb
\emph default
.
 
\emph on
cli_get_barcodes
\emph default
 ist so aufgebaut, dass alle möglichen Fehler abgefangen werden und zu Fehlern
 die dem Nutzer (der potentiell mit einer Python Fehlermeldung nichts anfangen
 kann) mehr sagen gewandelt werden.
 Jedoch ist in manchen Fällen ein sog.
 
\emph on
Traceback
\emph default
 nützlich, daher ist es über den Parameter 
\emph on
-tb
\emph default
 möglich, die benutzerdefinierten Fehler abzustellen und stattdessen einen
 Python Traceback zu erhalten.
\end_layout

\begin_layout Standard
Das CLI läuft schlussendlich auf einem Server und kann über eine RESTful
 API angesprochen werden.
 Um hier ein einfaches Setup zu ermöglichen, wird es mittels pyinstaller
 als 
\emph on
onefile
\emph default
 bzw 
\emph on
onedir
\emph default
 Lösung verpackt.
 Hierbei wird zum Beispiel für Windows eine exe erzeugt, die eine volle
 Python Installation und alle benötigten Packages beinhaltet.
 Die 
\emph on
onefile
\emph default
 Lösung stellt sich jedoch als eher ungeeignet heraus, da hier zum Programmstart
 ein Archiv temporär entpackt wird, was einen enormen Overhead schafft,
 der bei so kurzer Programmlaufzeit nicht gerechtfertigt ist.
 Daher wurde das CLI dem Auftraggeber als Linux-onedir-Variante übergeben.
\end_layout

\begin_layout Section
SQLAlchemy
\end_layout

\begin_layout Standard
Bei SQLAlchemy handelt es sich um ein Open-Source SQL Toolkit und einen
 objektrelationalen Mapper für Python.
\end_layout

\begin_layout Standard
Lesenswert im Bezug auf die Grundidee, bzw.
 Architekturentscheidungen von SQLAlchemy ist hierzu, das von Michael Bayer,
 dem/einem Entwickler von SQLAlchemy, in 
\emph on
The Architecture of Open Source Applications  (Volume 2)
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "18.12.18 - 17:26 Uhr"
key "OpenSourceArchitect"
literal "false"

\end_inset


\end_layout

\end_inset

 veröffentlichte Kapitel über SQLAlchemy.
 Hieraus geht hervor, dass SQLAlchemy so entworfen wurde, dass man bei der
 Entwicklung damit gewillt sein muss, die relationalen Strukturen seiner
 Daten zu bedenken, die Implementierung dieser jedoch durch eine High-Level-Schn
ittstelle erfolgen sollte.
 Dieser Abstraktionslayer ermöglicht es SQLAlchemy mit den verschiedensten
 Datenbanken  (SQLite, PostgreSQL, Oracle,...) zu arbeiten, ohne große  (wenn
 überhaupt) Änderungen am Code vorzunehmen.
 Diese verschiedenen Implementierungen werden alle über dieselbe High-Level
 API angesprochen und im SQLAlchemy-Jargon 
\begin_inset Quotes eld
\end_inset

dialect
\begin_inset Quotes erd
\end_inset

 genannt.
 Ein weiteres grundsätzliches Merkmal ist, dass SQLAlchemy grob in ein Core-Modu
l und ein darauf aufsetzendes ORM-Modul aufgeteilt werden kann.
 Viele Firmen bauen auf dem Core basierend einen eigenen ORM auf.
 Die Details dieser Struktur sind der umfangreichen SQLAlchemy-Dokumentation
 zu entnehmen.
\end_layout

\begin_layout Subsection
Das Datenbankmodell
\end_layout

\begin_layout Standard
Das mit SQLAlchemy umgesetzte Datenbankmodell wurde zunächst wie folgt geplant:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/ERD.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Entity-Relationship-Diagramm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es sollte also Geräte geben, deren Standort verfolgt wird und die immer
 einen Mitarbeiter zugewiesen haben, der für sie verantwortlich ist.
 Um eine einfachere Pflege der Datenbank zu ermöglichen, wurden der Artikel
 eines Geräts sowie dessen Hersteller ausgekapselt  (3.
 Normalform).
\end_layout

\begin_layout Subsection
Implementierung des Datenbankmodells
\end_layout

\begin_layout Standard
Auf Basis dieses ERM wurden Klassen wie folgt erstellt:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/UML.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
UML-Diagramm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Klassen erben alle von einer abstrakten Basisklasse 
\emph on
Base
\emph default
, die von SQLAlchemy bereitgestellt wird, und besitzen jeweils einen eigenen
 Datenbank-Table.
 Auch die Beziehungen der Klassen werden auf Basis des Quellcodes automatisch
 von SQLAlchemy erzeugt.
\end_layout

\begin_layout Subsection
Benutzerdefinierte Datentypen
\end_layout

\begin_layout Standard
Da SQLAlchemy im Hintergrund eine tatsächliche SQL-Datenbank einsetzt, ist
 es natürlich an deren Datentypen gebunden.
 Daher ist es hier, ähnlich einer traditionellen DBAPI, nötig, Adapter zu
 schreiben, um eigene Datentypen ablegen zu können.
 Konkret geht es darum, das 
\emph on
salt
\emph default
 eines Nutzers in der Datenbank zu speichern.
 Das Salt ist eine sehr große Zahl.
 Daher wird ein eigener Datentyp benötigt, welcher den Python-seitigen Wert
 beim Speichern in die Datenbank zu einem String konvertiert und beim Abrufen
 die umgekehrte Umwandlung durchführt.
 SQLAlchemy stellt hierzu die abstrakte Klasse 
\emph on
TypeDecorator
\emph default
 zur Verfügung, von dieser leiten wir eine Klasse 
\emph on
BigInt
\emph default
 ab.
 Als Klassenvariable legen wir über 
\emph on
impl
\emph default
 fest, dass die datenbankseitige Implementierung als string erfolgt, die
 beiden Methoden 
\emph on
process_bind_param 
\emph default
und
\emph on
 process_result_value
\emph default
 nehmen die Umwandlung vor.
 Es ist auch möglich, je nach 
\emph on
dialect
\emph default
 der Datenbank, verschieden umzuwandeln, dies ist hier allerdings nicht
 nötig.
\end_layout

\begin_layout Subsection
Beziehungen herstellen in SQLAlchemy
\end_layout

\begin_layout Subsubsection
Grundprinzip und 1-zu-n-Beziehungen
\end_layout

\begin_layout Standard
In SQLAlchemy werden Beziehungen zwischen Tables mittels der 
\emph on
relationship
\emph default
 Methode hergestellt.
 Die Variante, für die wir uns entschieden haben, nutzt hierbei 
\emph on
backref
\emph default
:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/1-zu-n.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel einer 1-zu-n Beziehung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird also in einer Klasse lediglich ein Fremdschlüssel festgelegt.
 In der anderen Klasse wird das 
\emph on
relationship
\emph default
 gesetzt.
 Dieses 
\emph on
relationship
\emph default
 stellt hierbei bei jeder Instanz von 
\emph on
Parent
\emph default
 eine Liste aller 
\emph on
Children
\emph default
-Instanzen zur Verfügung.
 Umgekehrt legt 
\emph on
backref
\emph default
 bei 
\emph on
Children
\emph default
 den Member 
\emph on
parent
\emph default
 an, welcher auf die zugehörige Parent-Instanz verweist.
 Hier gilt zu beachten, dass es egal ist, auf welcher Seite der Beziehung
 der Fremdschlüssel hinterlegt ist.
\end_layout

\begin_layout Standard
Außerdem ist das erste Argument von 
\emph on
relationship
\emph default
 nicht die Klasse 
\emph on
Child
\emph default
, sondern ein String, der ihren Namen enthält.
 Dies ermöglicht es, Beziehungen anzulegen, ohne dass, die Partnerklasse
 bereits angelegt wurde bzw.
 bekannt ist, was das Arbeiten wesentlich komfortabler macht.
\end_layout

\begin_layout Subsubsection
1-zu-1-Beziehung
\end_layout

\begin_layout Standard
Es lassen sich mit SQLAlchemy jedoch nicht nur 1-zu-n-Beziehungen anlegen.
 Durch Erweiterung der 
\emph on
relationship
\emph default
 Methode mit dem 
\emph on
uselist
\emph default
 Parameter lässt sich auf folgende Weise an beiden Seiten des relationships
 eine Einzelinstanz hinterlegen.
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/1-zu-1.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel einer 1-zu-1 Beziehung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prinzipiell ist es auch möglich, n-zu-n Beziehungen-herzustellen, dies ist
 bei uns jedoch nicht nötig und wird daher nicht aufgeführt.
\end_layout

\begin_layout Subsection
Arbeiten mit SQLAlchemy
\end_layout

\begin_layout Standard
Beim Arbeiten mit SQLAlchemy gibt es ein sehr prominentes Konstrukt: 
\emph on
Session
\emph default
s
\end_layout

\begin_layout Standard
Über diese erfolgt die komplette Interaktion mit der Datenbank, sie erledigt
 im Hintergrund jedoch auch Dinge wie 
\begin_inset Quotes eld
\end_inset

State-Management
\begin_inset Quotes erd
\end_inset

  (Konsistenzstatus zwischen Objekt und Datenbank), was später noch eine
 wichtige Rolle spielt.
 Eine Session wird zunächst an eine 
\emph on
Engine
\emph default
  (dt.
 Datenbanktreiber) angebunden; diese Engine verwaltet z.B.
 den bereits erwähnten Dialect und stellt das Interface zur DBAPI und damit
 auch zur Datenbank dar.
 Über ihre Lebenszeit kann man einer Session Objekte manuell oder über Abfragen
 hinzufügen, sie entfernen und Änderungen an der Datenbank vornehmen.
 Oftmals, so auch in unserem Fall, gibt es jedoch viele Stellen, von denen
 aus auf eine Session zugegriffen werden muss.
 Da stellt man sich natürlich die Frage, wann man denn eine neue Session
 aufmacht und schließt etc..
 Hierzu steht in der Dokumentation von SQLAlchemy:
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

When do I construct a Session, when do I commit it, and when do I close
 it? [...] Make sure you have a clear notion of where transactions begin and
 end, and keep transactions short, meaning, they end at the series of a
 sequence of operations, instead of being held open indefinitely.
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "22.12.18 - 16:41 Uhr"
key "SessionBasics"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Subsection

\emph on
ContextSession
\emph default
s
\end_layout

\begin_layout Standard
Dies und der Fakt, dass eine Session stets ordnungsgemäß initialisiert und
 deinitialisiert werden muss, führt uns daher ein weiteres Mal zu einem
 Kontext-Manager.
 Dieser Kontext-Manager verfügt über die Engine, zu der alle Sessions verbunden
 werden, sowie einen sog.
 
\emph on
sessionmaker
\emph default
.
 Dieser Sessionmaker kümmert sich um die Konfiguration der erzeugten Sessions.
 Da es jedoch potentiell wünschenswert ist, mehrere Datenbanken zu haben
  (z.B.
 lokale Datenbank für Geräte und remote Datenbank für Nutzerdaten), wird
 im Hinblick auf Zukunftssicherheit und Maintainability, eine Variante gewählt,
 die es erlaubt, mehrere Kontext-Manager für Sessions auf verschiedenen
 Engines zu haben.
 Damit steht eine Fabrikmethode  (
\emph on
setup_context_session
\emph default
) zur Verfügung, der eine Engine übergeben wird und die den Kontext-Manager
 als Klasse zurückgibt.
 Die zurückgegebene Klasse kümmert sich dann um eventuelle Rollbacks im
 Fehlerfall etc..
 Es ist wichtig zu beachten, dass Methoden, die im Hintergrund zu 
\emph on
INSERT
\emph default
, DELETE oder UPDATE evaluiert werden, erst beim Aufrufen der Methoden 
\emph on
flush
\emph default
 oder 
\emph on
commit
\emph default
 der Session tatsächlich geschrieben werden, sofern kein 
\emph on
autocommit
\emph default
 eingestellt ist.
 
\end_layout

\begin_layout Standard
Der Aufbau der Fabrikmethode ist in soweit non-trivial, dass in ihr eine
 Klasse definiert wird in der widerrum weitere Klassen definiert werden,
 welche mitunter voneinander erben.
 Dieses vielleicht überkompliziert anmutende Konstrukt, ist eigentlich nicht
 nötig, stellt aber eine sehr elegante Lösung dar und ist tatsächlich sehr
 einfach erklärt.
 Die erste innere Klasse wurde bereits erläutert und ist die, welche von
 der Funktion schließlich zurückgegeben wird.
 In dieser wird über den 
\emph on
sessionmaker
\emph default
 von SQLAlchemy eine Klasse 
\emph on
_Session
\emph default
 erzeugt - auf Instanzen dieser können bereits Datenbankoperationen durchgeführt
 werden, i.d.R.
 wird das bei SQLAlchemy auch so gemacht.
 Wir hingegen erben nun von dieser Klasse.
 Im Konstruktor der abgeleiteten Klasse delegieren wir die tatsächliche
 Initialisierung zum Konstruktor der Grundklasse und hinterlegen eine leere
 Liste, welche uns später als Cache dient.
 Desweiteren redefinieren wir die Methode 
\emph on
add
\emph default
 der Grundklasse
\begin_inset Foot
status open

\begin_layout Plain Layout
Tatsächlich werden dem gleichen Prinzip folgend, weitere Methoden redefiniert
\end_layout

\end_inset

, in ihr wird nun jede übergebene Instanz zum vorher angelegten Cache hinzugefüg
t und anschließend der Funktionsaufruf wieder an die Basisklasse delegiert.
 Dieses Cache ermöglicht es der Session sobald ihr Kontext verlassen wird,
 alle hinzugefügten Instanzen zu 
\begin_inset Quotes gld
\end_inset

refreshen
\begin_inset Quotes grd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Dieser refresh wird mittels 
\emph on
map
\emph default
 durchgeführt.
 Eigentlich ist 
\emph on
map
\emph default
 eine Funktion, um eine Funktion auf alle Elemente eines iterierbaren Objektes
 anzuwenden und aus den Ergebnissen eine Liste zu erstellen.
 Hier wird die Ergebnisliste jedoch verworfen, map wird lediglich für die
 Seiteneffekte genutzt.
 
\end_layout

\end_inset

.
 Hierbei wird die Instanz mit der Datenbank synchronisiert - die meisten
 Objekte erhalten hier ihre UID von der Datenbank.
 Später wurde die innerste Klassendefinition dahingegend geändert, dass
 der 
\emph on
sessionmaker
\emph default
 entfällt.
 Stattdessen wird von der 
\emph on
Session
\emph default
 Grundklasse geerbt und die Konfiguration selbst durchgeführt.
\end_layout

\begin_layout Subsubsection
Neue Einträge in der Datenbank vornehmen
\end_layout

\begin_layout Standard
Nachdem die Vorarbeit mit Sessions und Klassen geleistet ist, ist es nun
 sehr einfach, neue Einträge in der Datenbank vorzunehmen.
 Das folgende Beispielprogramm zeigt, wie einige bereits erzeugte Objekte
 in der Datenbank abgelegt werden.
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/In_DB_schreiben.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Objekte in Datenbank ablegen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie zu sehen ist, können sehr komfortabel entweder einzelne Objekte oder
 eine ganze Reihe von ihnen auf einmal geschrieben werden.
 Commits, Rollbacks etc.
 werden automatisch im Hintergrund gehandled.
\end_layout

\begin_layout Subsubsection
Abfragen
\end_layout

\begin_layout Standard
Abfragen können auf zwei verschiedenen Wegen erfolgen:
\end_layout

\begin_layout Itemize
direkt über SQL Querys
\end_layout

\begin_layout Itemize
über die 
\emph on
query-
\emph default
Methode einer 
\emph on
Session
\emph default
 Instanz
\end_layout

\begin_layout Standard
Bei TUInventory wurde ausschließlich der objektorientierte Abfrageansatz
 eingesetzt.
 Als Beispiel dient hier die Abfrage  (wenn auch nicht in finaler Version),
 die im Zusammenhang des Einloggens eines Users auftritt:
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/Abfrage.py"
lstparams "language=Python,breakautoindent=true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Abfrage aus Datenbank anhand eines tatsächlichen Beispiels
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die wichtigen Punkte sind hier die Zeilen 6 und 10.
 In Zeile 6 wird über die 
\emph on
query
\emph default
-Methode eine Abfrage auf dem Table der 
\emph on
User
\emph default
 vorgenommen.
 Das Ergebnis dieser Abfrage wird anschließend mittels 
\emph on
filter_by
\emph default
 anhand der Spalte 
\emph on
e_mail
\emph default
 in der Datenbank mit der übergebenen E-mail Adresse gefiltert.
 Dies gibt uns ein 
\emph on
Query
\emph default
 Objekt.
 Da die Spalte 
\emph on
e_mail
\emph default
 mit 
\emph on
unique
\emph default
 gekennzeichnet ist, wird nur ein Objekt abgefragt, dieses erhalten wir
 mit 
\emph on
first
\emph default
.
 Nun wird dieses Objekt verarbeitet bis zu Zeile 10, hier wird die Methode
 
\emph on
expunge
\emph default
, zu deutsch auslöschen der Session genutzt, um das Objekt von der Session
 zu trennen, sodass es auch außerhalb von ihr seine Gültigkeit behält.
 Ein Grund, wieso dies nötig ist, ist die Tatsache, dass SQLAlchemy hier,
 wie auch in vielen anderen Bereichen sehr 
\begin_inset Quotes gld
\end_inset

lazy
\begin_inset Quotes grd
\end_inset

 ist  (siehe 
\emph on
Lazy Evaluation
\emph default
).
 Tatsächlich fragt es nämlich nicht direkt das ganze Objekt ab, sondern
 erstmal nur das Attribut 
\emph on
e_mail
\emph default
, da dieses gerade gebraucht wird.
 Im Verlauf bis Zeile 10 werden noch 
\emph on
salt
\emph default
 und 
\emph on
password
\emph default
 just-in-time abgefragt und damit der Klasse hinzugefügt.
 Wenn die Instanz jedoch mit 
\emph on
expunge
\emph default
 von der Session getrennt wird, erfolgt eine Abfrage aller restlichen Attribute,
 sodass das Objekt vollständig ist.
 Wer mit SQL vertraut ist, hat sicherlich bereits erkannt, dass die Methoden
 dieselben Namen wie einige Operationen in SQL tragen.
 Analog stehen auch zu weiteren SQL Operationen Methoden bereit, um komplexere
 Abfragen zu realisieren.
\end_layout

\begin_layout Subsubsection
Aktualisieren und Löschen einer Instanz
\end_layout

\begin_layout Standard
Möchte man eine Instanz in der Datenbank ändern, ist dies ebenfalls mit
 einer Session einfach umzusetzen.
 So muss man lediglich die Instanz in einer Session verfügbar machen  (entweder
 sie ist ohnehin schon darin oder wird über eine Abfrage ermittelt), seine
 Änderungen vornehmen und den Kontext der aktuellen 
\emph on
ContextSession
\emph default
 verlassen, bzw.
 die Methode 
\emph on
commit 
\emph default
der
\emph on
 Session aufrufen
\emph default
.
 Im Fall der Löschung ist es möglich eine Instanz über die Methode 
\emph on
delete
\emph default
 der Session als gelöscht zu markieren, tatsächlich ist sie aber nicht direkt
 gelöscht, sondern auch hier erst, sobald der Kontext verlassen wird oder
 
\emph on
flush
\emph default
 oder 
\emph on
commit
\emph default
 aufgerufen wird.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Frameworkfreie Implementierung
\end_layout

\begin_layout Subsection
Utilities
\end_layout

\begin_layout Standard
Bei der Entwicklung wurde ein kleines Hilfsmodul geschrieben, um einige
 Sachen zu vereinfachen.
 Dieses Hilfmodul ist nicht abhängig von einem der anderen Module.
\end_layout

\begin_layout Subsubsection
Absolute Pfade
\end_layout

\begin_layout Standard
Python bietet grundsätzlich die Möglichkeit an, mit relativen Pfaden zu
 arbeiten.
 Diese sind jedoch so umgesetzt, dass sie nicht relativ zur Quelldatei interpret
iert werden, sondern stattdessen relativ zum Aufruf arbeiten.
 Führe ich das Python Programm in der Konsole also von einem anderen Ordner
 aus aus, so wird auf eine andere Datei zugegriffen.
 Daher wurde eine Funktion entwickelt, die ermittelt, wo sich die Quellcodedatei
 befindet und ein 
\emph on
pathlib
\emph default
 Objekt zum übergebenen relativen Pfad zurückgibt.
 Die Pfad-Objekte des Moduls 
\emph on
pathlib
\emph default
 sind plattformunabhängig und sehr komfortabel in der Nutzung  (Beispielsweise:
 Erweiterung mittels Verwendung des überladenen /-Operators).
\end_layout

\begin_layout Subsubsection
Paralleles Printen
\end_layout

\begin_layout Standard
Beim Debuggen ist es oftmals hilfreich sich kleinere Nachrichten an Schlüsselpun
kten ausgeben zu lassen.
 Da diese Nachrichten oftmals jedoch aus verschiedenen Threads kommen, kann
 sich hier eine race-condition auf der Konsole abbilden, bei der mehrere
 Nachrichten gleichzeitig ausgegeben werden, wodurch sie schwer bis garnicht
 zu verwerten sind.
 Daher wird ein Singleton-Thread geöffnet, der über eine Queue Nachrichten
 empfangen und auf der Konsole ausgeben kann.
 Um eine sauberere Schnittstelle zu haben, wird die 
\emph on
put
\emph default
-Methode seiner Queue von der Module-Level-Referenz
\emph on
 parallel_print
\emph default
 gespiegelt, über die dann aus allen Modulen sauber zugegriffen werden kann.
 Die Umsetzung des Singletons ist so, dass es einem Anwender von außerhalb
 des Moduls nicht möglich ist, eine weitere Instanz der Klasse 
\emph on
_ParallelPrint
\emph default
 zu erzeugen  (Zumal das 
\begin_inset Quotes gld
\end_inset

_
\begin_inset Quotes grd
\end_inset

 im Namen nach Konvention angibt, dass es sich um eine Klasse handelt, die
 in der API nicht aus Gründen der Nutzung von außen vorhanden ist
\begin_inset Foot
status open

\begin_layout Plain Layout
Ein Nutzer kann eine mit 
\begin_inset Quotes gld
\end_inset

_
\begin_inset Quotes grd
\end_inset

-benannte Klasse/Methode/Instanz etc.
 zwar dennoch verwenden, sollte dabei allerdings die internen Mechanismen
 im Hinterkopf behalten und ist sogesagt im Fehlerfall auf sich alleine
 gestellt
\end_layout

\end_inset

), indem die Referenz von 
\emph on
_ParallelPrint
\emph default
 nicht mehr auf der Klasse, sondern auf einer Instanz dieser liegt.
 Probiert er nun, eine Instanz zu erzeugen, wird stattdessen die Magic Method
 
\emph on
__call__ 
\emph default
der Instanz aufgerufen, welche eine 
\emph on
Warning
\emph default
 wirft.
 Sofern ein Nutzer des Moduls zwischen Klassendefinition und Umleitung der
 Referenz im Modulkörper selbst eine weitere Instanz erzeugen würde, könnten
 zwei Instanzen erzeugt werden.
 Um dies zu verhindern, existiert eine Klassenvariable 
\emph on
_created
\emph default
, welche bei der ersten Instanziierung gesetzt wird und bei jeder weiteren
 eine Warnung hervorruft.
 Sollte ein Nutzer diese Klassenvariable manuell zurücksetzen, liegt dies
 außerhalb der zu erwartenden Nutzung und wird nicht mehr abgefangen.
\end_layout

\begin_layout Subsubsection
Dateitools - Pfadvalidierung und Normalisierung von Dateinamen 
\begin_inset Marginal
status open

\begin_layout Plain Layout
td
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Standard
Beim Logging werden an interessanten Punkten (Datenbankinteraktion, Nutzeranmeld
ung, Fehler etc.) in der Anwendung, Nachrichten in eine Datei geschrieben.
 Die Implementierung erfolgt mittels des 
\emph on
logging
\emph default
-Moduls aus Pythons Standardbibliothek.
 Dieses wurde so konfiguriert, dass die geschriebenen Datensätze folgende
 Informationen enthalten:
\end_layout

\begin_layout Itemize
Zeitstempel nach ISO 8601 im Format YYYY-MM-DDThh:mm:ss
\end_layout

\begin_layout Itemize
Logtyp  (Fehler, Debugnachricht, Information, kritischer Fehler o.ä.)
\end_layout

\begin_layout Itemize
Dateiname
\end_layout

\begin_layout Itemize
Funktionsname, aus dem der Log kommt
\end_layout

\begin_layout Itemize
Nachricht
\end_layout

\begin_layout Standard
Somit sollte es im Fehlerfall möglich sein, leicht herauszufinden, wo eine
 Fehlerquelle liegt.
 Der Aufbau eines Log-Datensatzes ist dabei so, dass rechts die am meisten
 relevante und links die am wenigsten relevante Information liegt und jeder
 Abschnitt eine konstante Breite aufweist.
 Eine Beispieldatei könnte dann so aussehen:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Logger-Beispiel.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Log-Datei Beispiel
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist zu sehen, dass sich die Datei Spaltenweise gut lesen lässt und leicht
 zurückverfolgbar ist, woher eine Nachricht stammt.
 Bei Nachricht 1 und 3 ist ein 
\emph on
<module>
\emph default
 im Funktionsslot zu sehen; dies bedeutet, dass die Nachricht nicht aus
 einer Unterfunktion sondern vom Modul selbst stammt.
 Die beiden Nachrichten aus 
\emph on
main
\emph default
 hingegen kamen aus den Funktionen 
\emph on
test
\emph default
 und 
\emph on
info
\emph default
.
 Ebenfalls zu sehen ist, dass der Leitgedanke, des von rechts nach links
 absteigend relevanten Informationslevels sich sehr gut mit ISO 8601 kombinieren
 lässt, da die Sekunden die wohl wichtigste Information der Zeit darstellen.
 Auf die Darstellung der Millisekunden  (bzw.
 ggf.
 Microsekunden etc.) wurde verzichtet, da der Nutzer die Anwendung eher im
 Sekundentakt bedient und sich somit die Zeile nicht unnötig überlädt.
 Aus demselben Grund wäre es denkbar, auf die Jahreszahl zu verzichten.
\end_layout

\begin_layout Subsection
Barcode Reader - die Klassen VideoStream und LazyVideoStream
\end_layout

\begin_layout Standard
Um Geräte identifizieren und markieren zu können, wird für jedes Gerät ein
 einzigartiger QR-Code erzeugt.
 Um diese einzulesen, wird 
\emph on
OpenCV
\emph default
 mit 
\emph on
ZBar
\emph default
 verwendet.
 Die Funktionalität des Einlesens ist im Modul 
\emph on
barcodereader
\emph default
 gekapselt.
\end_layout

\begin_layout Standard
Der Barcode Reader wird anfangs als Prozedur geschrieben.
 Sobald die Funktion gegeben ist, wird er in eine Klasse umgewandelt und
 für die später benötigte Parallelisierung vorbereitet
\begin_inset Foot
status open

\begin_layout Plain Layout
Eine genaue Erklärung einiger Prozesse des parallelen Programmierens erfolgt
 im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Automatisches-Abmelden"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset

.
 Dabei gibt es grundsätzlich zwei Optionen:
\end_layout

\begin_layout Enumerate
Die zuerst implementierte: Der Thread arbeitet im Polling-Betrieb und stellt
 kontinuierlich das aktuellste Frame an seiner Schnittstelle bereit.
 Hierbei wird auf 
\emph on
Mutex
\emph default
 gesetzt um Threadsicherheit zu gewährleisten.
\end_layout

\begin_layout Enumerate
Beim Thread kann ein Frame angefragt werden, er antwortet anschließend mit
 einem Frame - realisiert wird dieser Vorgang durch 
\emph on
Atomic-Message- Queues
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Eine Erklärung dieser Konstrukte, von Raymond Hettinger, der sie entwickelt/impl
ementiert hat, gab es u.a.
 auf der PyCon Russia 2016 
\begin_inset CommandInset citation
LatexCommand cite
after "20.12.18 - 23:03 Uhr"
key "ThinkConcurrent"
literal "false"

\end_inset


\end_layout

\end_inset

, welche ein weiterer Weg zur Threadsicherheit sind.
\end_layout

\begin_layout Standard
Beide Varianten setzen dabei auf einen sog.
 
\emph on
Daemon-Thread
\emph default
 - einen Thread, der nach seinem Starten niemals mit seiner 
\begin_inset Quotes eld
\end_inset

Aufgabe
\begin_inset Quotes erd
\end_inset

 fertig ist  (es gibt immer wieder neue Frames zum Auswerten).
\end_layout

\begin_layout Standard
Die Vermutung beim Auswählen des Prozesses ist, dass die Polling-basierte
 Variante schneller, jedoch rechenintensiver ist.
 Demgegenüber steht die Queue-basierte Variante, welche nur so viele Bilder
 wie nötig verarbeitet, jedoch nach Anfrage länger braucht, um ein Bild
 zurückzugeben.
 Daher wird mit einer einfachen Funktion eine statistische Gegenüberstellung
 der beiden Methoden durchgeführt.
 Die Funktion erhält hierbei einen Wert, inkrementiert diesen und meldet
 ihn zurück.
 Durchgeführt wurde dies für den Bereich [0:20e3].
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Bilder/Polling_vs_Queues_cropped.png
	width 75page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Gegenüberstellung-von-Polling"

\end_inset

Gegenüberstellung von Polling und Queues
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Gegenüberstellung-von-Polling"
plural "false"
caps "false"
noprefix "false"

\end_inset

 zu sehen ist, war die ursprüngliche Vermutung korrekt.
 Polling bietet wesentlich bessere Response Times, da es nicht reagiert,
 sondern proaktiv die Schnittstelle aktualisiert.
 Was jedoch auch zu erkennen ist: Bis das Ergebnis erreicht war, wurden
 bei der Queue-Variante lediglich die 20000 minimalen Lesezugriffe  (Auf
 unseren use-case Übertragen also Aktualisierungen des Video-Feeds in der
 UI) durchgeführt - beim Polling fanden mehr als doppelt so viele Lesezugriffe
 statt  (über mehrere Versuche ließ sich der tatsächliche Wert auf ~44e3
 bis ~48e3 festmachen); es wurden konsekutiv mehrfach die gleichen Werte
 abgefragt.
 Es liegt also bei mehr Rechenzeit kein tatsächlicher Informationszuwachs
 vor.
 Betrachtet man die beiden Verfahren als Signale und bildet deren SNR, gilt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$SNR_{AMQ} = 1 $$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$SNR_{Polling} 
\backslash
approx 0,5$$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei diesen Zahlen ist selbstverständlich zu beachten, dass diese lediglich
 auf einer sample size von 1 beruhen und somit nur bedingt aussagekräftig
 sind.
\end_layout

\begin_layout Standard
Generell ist es bei einer Echtzeit-Kamera-Anwendung wünschenswert, bessere
 Response Times zu haben - im Praxisversuch zeigt sich jedoch, dass die
 Message Queues auf den Testgeräten ein flüssiges Bild liefern, daher wurde
 diese gewählt.
 Jedoch steht auch die Klasse für Polling weiterhin bereit und ist wegen
 ihrer ähnlichen Schnittstelle, durch geringe Quellcodeänderung einzubinden
 oder alternativ für eine andere Anwendung einsetzbar.
\end_layout

\begin_layout Standard
In der konkreten Implementierung wird zum Anfragen eines Frames eine Queue
 genutzt; es stellt sich die Frage, wieso hierzu kein 
\emph on
Event
\emph default
 genutzt wurde.
 Solange lediglich ein Consumer auf den 
\emph on
LazyVideoStream
\emph default
 zugreift, hätte ein Event genauso funktioniert, jedoch treten bei mehreren
 Consumern Probleme auf.
 Wenn beispielsweise ein Thread, der die Barcodes auswertet, einen Frame
 anfragt, gleichzeitig allerdings die UI ein neues Frame zum Anzeigen anfragt,
 würden beide das Event starten, was beide Male intern das gleiche Flag
 auf True setzt; im Kontrast könnten beide separate Anfragen in der Request-Queu
e anlegen.
 Also würde der VideoStream auf das Event antworten, indem er ein Frame
 in seine Antwort-Queue legt.
 Einer der Konsumenten könnte dieses Frame herausnehmen, der andere jedoch
 würde leer ausgehen; bei der Anfragen-Queue-Variante hingegen würde er
 beide Anfragen mit einem Frame beantworten.
\end_layout

\begin_layout Standard
Weiterhin stellt sich die Frage, wieso auch die Antworten über eine Queue
 geregelt sind, anstatt auf eine gelockte Property zu setzen: Die Request-Respon
se Variante hat den Vorteil, dass es nicht möglich ist, veraltete Daten
 abzufragen.
 Jeder der ein Frame von der Kamera möchte, ist gezwungen vorher eine Abfrage
 zu starten - daher ist dieses grundsätzlich aktuell.
\end_layout

\begin_layout Standard
Dieser Mechanismus hätte, nach folgendem Schema auch in einer Property gekapselt
 werden können:
\end_layout

\begin_layout Itemize
bei 
\emph on
get-Zugriff
\emph default
 der Property wird intern eine Abfrage in der Request-Queue abgelegt
\end_layout

\begin_layout Itemize
blockierende Methode 
\emph on
get
\emph default
 der Response-Queue wird aufgerufen
\end_layout

\begin_layout Itemize
Daten werden zurückgegeben
\end_layout

\begin_layout Standard
Hierauf wurde jedoch verzichtet, da man bei manuellem Zugriff auf die Queues
 die Laufzeit der Bildabfrage mit einkalkulieren kann.
 Zum Beispiel weiss man an Punkt A, dass man bald ein Frame benötigt, also
 fragt man es an.
 Danach erledigt man einige andere Arbeiten, bis man das Frame an Punkt
 B tatsächlich entgegennimmt und verarbeitet.
\end_layout

\begin_layout Subsection
Auslesen von Barcodes und grundlegende Aufbereitung von Frames
\end_layout

\begin_layout Standard
Die Funktionalität des Barcode-Auslesens und eine erste Bearbeitung der
 Frames findet in der Methode 
\emph on
find_and_mark_barcodes
\emph default
 der VideoStream Klassen statt.
 Der Methode wird ein Frame übergeben, auf dem dann operiert wird.
\end_layout

\begin_layout Standard
Grundsätzlich gibt es zwei gängige Formate, in denen Bilder im Speicher
 dargestellt werden:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{2}
\end_layout

\begin_layout Plain Layout

	$$
\end_layout

\begin_layout Plain Layout

	A_1 = 
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{bmatrix}
\end_layout

\begin_layout Plain Layout

		r_{11} & r_{12} & 
\backslash
cdots & r_{1n}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		r_{21} & r_{22} & 
\backslash
cdots & r_{2n}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
vdots &
\backslash
vdots  & 
\backslash
ddots & 
\backslash
vdots
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		r_{m1} & r_{m2} & 
\backslash
cdots & r_{mn}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
end{bmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{bmatrix}
\end_layout

\begin_layout Plain Layout

		g_{11} & g_{12} & 
\backslash
cdots & g_{1n}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		g_{21} & g_{22} & 
\backslash
cdots & g_{2n}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
vdots &
\backslash
vdots  & 
\backslash
ddots & 
\backslash
vdots 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		g_{m1} & g_{m2} & 
\backslash
cdots & g_{mn}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
end{bmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{bmatrix}
\end_layout

\begin_layout Plain Layout

		b_{11} & b_{12} & 
\backslash
cdots & b_{1n}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		b_{21} & b_{22} & 
\backslash
cdots & b_{2n}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
vdots &
\backslash
vdots  & 
\backslash
ddots & 
\backslash
vdots 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		b_{m1} & b_{m2} & 
\backslash
cdots & b_{mn}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
end{bmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
end{pmatrix}
\end_layout

\begin_layout Plain Layout

	$$
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	$$
\end_layout

\begin_layout Plain Layout

	A_2 = 
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{bmatrix}
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix} 
\end_layout

\begin_layout Plain Layout

				r_{11} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

				g_{11} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

				b_{11} 
\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix} &
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix} 
\end_layout

\begin_layout Plain Layout

				r_{12} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

				g_{12} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

				b_{12} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix} &
\end_layout

\begin_layout Plain Layout

			
\backslash
cdots & 
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix} 
\end_layout

\begin_layout Plain Layout

				r_{1n} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

				g_{1n} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

				b_{1n} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

				r_{21} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				g_{21} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				b_{21} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}&
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

				r_{22} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				g_{22} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				b_{22} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}&
\end_layout

\begin_layout Plain Layout

	        
\backslash
cdots& 
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

				r_{2n} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				g_{2n} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				b_{2n} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

			
\backslash
vdots &
\backslash
vdots  & 
\backslash
ddots & 
\backslash
vdots 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

				r_{m1} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				g_{m1} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				b_{m1} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}&
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

				r_{m2} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				g_{m2} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				b_{m2} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}&
\end_layout

\begin_layout Plain Layout

	        
\backslash
cdots& 
\end_layout

\begin_layout Plain Layout

			
\backslash
begin{pmatrix}
\end_layout

\begin_layout Plain Layout

				r_{mn} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				g_{mn} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

				b_{mn} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

			
\backslash
end{pmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
end{bmatrix}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	$$
\end_layout

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$A_1$
\end_layout

\end_inset

 ist dabei ein Vektor(zwecks Übersichtlichkeit - im Code ist es ein beliebiger
 Container) mit je einer Matrix pro Farbkanal.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$A_2$
\end_layout

\end_inset

 ist hingegen eine Matrix, welche dann einen Vektor je Farbkanal enthält.
\end_layout

\begin_layout Standard
Da einige Zeilen der Auswertung nontrivial sind, wird die Funktion hier
 im Detail durchgesprochen.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/barcodereader.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Methode 
\emph on
find_and_mark_barcodes
\emph default
 der beiden VideoStream Klassen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Ablauf ist wie folgt:
\end_layout

\begin_layout Enumerate
Über pyzbar, eine Python Bibliothek, die es ermöglicht Barcodes aus Bildern
 auszulesen, werden alle Barcodes aus dem Frame ausgelesen.
\end_layout

\begin_layout Enumerate
Es wird eine leere Liste 
\emph on
found_codes
\emph default
 angelegt und über alle Barcodes iteriert
\end_layout

\begin_deeper
\begin_layout Enumerate
Es wird ein Tupel angelegt, dass den Barcode Typ (z.B.
 EAN-14 oder QR-Code) und die enthaltenen Daten mit UTF-8 codiert enthält.
\end_layout

\begin_layout Enumerate
Nun wird überprüft ob dieses Tupel bereits in 
\emph on
found_codes
\emph default
 hinterlegt ist, wenn nicht wird es hinzugefügt.
 Grundsätzlich gäbe es hier zwei Alternativlösungen.
 Man könnte entweder nicht überprüfen ob das Tupel bereits enthalten ist,
 und found_codes am Ende in ein 
\emph on
set
\emph default
 konvertieren, oder eine set-comprehension einsetzen um 
\emph on
found_codes
\emph default
 zu erzeugen.
 Sets sind dabei Python Container, die hashbare Instanzen in nicht geordneter
 Reihenfolge speichern.
 Sie sind soz.
 ein Dictionary, dass nur aus Schlüsseln besteht.
\end_layout

\begin_layout Enumerate
ZBar gibt 
\emph on
Barcode
\emph default
 Objekte zurück, die nebst dem tatsächlichen Payload des Codes, auch Metainforma
tionen wie z.B.
 Geometrien um den Code enthalten.
 Hier setzen wir den 
\emph on
polygon
\emph default
 Member ein, um jene Punkte (Pixel) zu erhalten, die ein Polygon um den
 Code im Bild bilden.
\end_layout

\begin_layout Enumerate
Wir bilden uns nun eine Liste, die Tupel mit allen Koordinatenpaaren dieser
 Punkte enthält und setzen diese als Parameter für die Funktion 
\emph on
np.asarray
\emph default
 ein.
 Dabei ist 
\emph on
np
\emph default
 die Bibliothek 
\emph on
numpy
\emph default
 - eine hochoptimierte Bibliothek die vor allem auf große Vektor und Matrixopera
tionen - also lineare Algebra - ausgerichtet ist.
 
\emph on
asarray
\emph default
 bildet nun aus der Liste aus Tupeln eine neue Struktur - das Array (tatsächlich
 ist es ein 
\emph on
ndarray
\emph default
 - ein n-dimensionales Array also
\emph on
)
\emph default
.
 Diese Arrays, wie auch praktisch alle Funktionen auf ihnen, sind durch
 NumPy direkt in C
\begin_inset Foot
status open

\begin_layout Plain Layout
Mitunter werden in numpy auch noch andere Sprachen wie z.B.
 Fortran eingesetzt
\end_layout

\end_inset

 implementiert.
\end_layout

\begin_layout Enumerate
Nun folgt ein Aufruf der 
\emph on
reshape
\emph default
 Methode.
 Diese ermöglicht es 
\emph on
arrays
\emph default
 effizient umzuformen (z.B.
 würde ein a.reshape(2 * len(a)) aus einem Array wie unserem, ein 1-dimensionales
 Array bilden).
 Über die -1 im übergebenen Tupel, teilen wir Numpy mit, dass es uns egal
 ist was es mit dieser Dimension macht, uns interessieren lediglich die
 anderen beiden, welche wir dann auf 1 bzw.
 2 setzen.
\end_layout

\begin_layout Enumerate
Die Folgende Zeile zeichnet nun, dem Array 
\emph on
poly
\emph default
 entsprechend ein Polygon auf unser Frame.
 True definiert das Polygon hierbei als geschlossenes Polygon, das Tupel
 (0,255,0) ein RGB Triplet das unsere Farbe festlegt und die 2 ist die Dicke
 der zu zeichnenden Linien.
\end_layout

\begin_layout Enumerate
Analog dazu wird noch ein Rechteck um den Code gezeichnet.
 Ein C-Programmierer würde die dabei vorkommenden Asteriske eventuell als
 Pointer deuten, tatsächlich handelt es sich jedoch um doppeltes Tupel-Unpacking.
 Zuerst rufen wir die statische Methode 
\emph on
rect_transformation
\emph default
 unserer Klasse auf.
 Diese führt eine Koordinatentransformation des 
\emph on
rect
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Von Englisch 
\begin_inset Quotes gld
\end_inset

rectangle
\begin_inset Quotes grd
\end_inset

 zu deutsch 
\begin_inset Quotes gld
\end_inset

Rechteck
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset

-Members des Barcode Obektes durch.
 Hierbei werden die Koordinaten der Form 
\begin_inset Quotes gld
\end_inset

Ursprung und Größe
\begin_inset Quotes grd
\end_inset

 in zwei absolute Eckpunktskoordinaten gewandelt.
 Das dabei zurückgegebene Tupel wird nun direkt wieder unpacked und kann
 gezeichnet werden.
\end_layout

\begin_layout Enumerate
Die anschließende Zeile ist eine sog.
 
\emph on
slice
\emph default
 Operation bei der wir die ersten beiden Elemente des 
\emph on
rect
\emph default
 Members nehmen, unpacken und in Variablen ablegen.
\end_layout

\begin_layout Enumerate
Mithilfe diese dieser Variablen und einem Offset wird nun ein Text auf das
 Frame gezeichnet.
 Dieser Text enthält den Typ des Codes, sowie seine Daten.
 Dies ist eine der wenigen, wenn nicht sogar die einzige Stelle, im gesamten
 Programm an der zur String-Interpolation kein f-String, sondern die alte
 
\emph on
str.format
\emph default
 Methode eingesetzt wird.
 Diese kann nämlich über Unpacking komfortabel Tuple verarbeiten - mit einem
 f-String hätte jedes Element einzeln angesprochen werden müssen.
\end_layout

\end_deeper
\begin_layout Enumerate
Sind alle Barcodes verarbeitet, werden das bearbeitete frame und alle gefundenen
 codes zurückgegeben.
\end_layout

\begin_layout Subsection
Weitere Kapselung: VideostreamUISync
\end_layout

\begin_layout Standard
Zwischen 
\emph on
VideoStream
\emph default
 und UI sitzt ein weiterer Abstraktionslayer.
 Dieser kümmert sich darum die Bilddaten auszuwerten, aufzubereiten und
 in der UI darzustellen.
 Konkret handelt es sich hierbei um einen weiteren Daemon-Thread, der bei
 seiner Instanziierung den 
\emph on
LazyVideoStream
\emph default
 von dem er seine Frames bekommt, sowie ein 
\emph on
canvas
\emph default
 übergeben bekommt.
 Das 
\emph on
canvas
\emph default
 ist ein beliebiges Qt Widget, das die Methode 
\emph on
setPixmap
\emph default
 implementiert.
 Tatsächlich verwendet Qt nämlich nicht einfach Matrizen zur Bilddarstellung,
 sondern implementiert hierzu eine eigene Klasse 
\emph on
QPixmap
\emph default
.
 Der Ablauf einer Schleifeniteration sieht wie folgt aus:
\end_layout

\begin_layout Enumerate
Anfrage eines Frames bei VideoStream
\end_layout

\begin_layout Enumerate
Abrufen der Antwort - Aufteilung in Bilddaten und Barcodes
\end_layout

\begin_layout Enumerate
Aufruf der Methode 
\emph on
_matrice_to_QPixmap
\end_layout

\begin_deeper
\begin_layout Enumerate
Farbkorrektur über Wandlung von BGR zu RGB mittels 
\emph on
cvtColor
\emph default
 Methode von OpenCV - dies ist grundsätzlich eine sehr simple Aufgabe, es
 werden je nach Aufbau der Matrix lediglich zwei Arrays getauscht.
 Der Einsatz der Methode erlaubt es jedoch, auf das Laden einer großen Bibliothe
k wie 
\emph on
numpy
\emph default
 (tatsächlich setzt opencv intern NumPy ein).
\end_layout

\begin_layout Enumerate
Ermitteln der Dimensionen der Matrix
\end_layout

\begin_layout Enumerate
Konstruktion eines 
\emph on
QImage
\emph default
; ein für Qt nötiges Zwischenkonstrukt.
 Hier werden alle Dimensionen und der gewünschte Farbraum (RGB mit 3x8bit)
 festgelegt.
\end_layout

\begin_layout Enumerate
Konstruktion und Rückgabe einer 
\emph on
QPixmap
\end_layout

\end_deeper
\begin_layout Enumerate
Schreiben des Frames in die UI
\end_layout

\begin_layout Enumerate
Sofern codes gefunden wurden, wird die Methode 
\emph on
update
\emph default
 des 
\emph on
Counters
\emph default
 
\emph on
barcodes
\emph default
 aufgerufen, falls ein Barcode als sicher erkannt eingestuft wird wird ein
 Qt Signal emmitiert, welches die UI entgegennimmt und verarbeitet
\end_layout

\begin_layout Enumerate
Kurze Verzögerung, die OpenCV benötigt um korrekt zu funktionieren.
\end_layout

\begin_layout Standard
In Schritt 5 wird ein Counter angesprochen.
 Counter sind eine Datenstruktur des Python Standartmoduls 
\emph on
collections
\emph default
, das spezielle, high-performance Containertypen zur Verfügung stellt
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "25.02.19 - 19:11 Uhr"
key "collections"
literal "false"

\end_inset


\end_layout

\end_inset

.
 Konkret ist ein Counter eine 
\emph on
HashMap
\emph default
, also ein Python dictionary, dass hashbare Objekte und ihre Häufigkeit
 in sich oder einer anderen Datenstruktur, wie einer Liste speichert.
 Dieser Counter ermöglicht es, Fehler der Barcodeerkennung (diese sind extrem
 selten, kommen jedoch vor) auzugleichen.
 Ein Barcode wird erst als korrekt erkannt anerkannt, wenn er in einer bestimmte
n Anzahl an Frames erkannt wurde.
 Der Thread implementiert außerdem Methoden um den Counter zurückzusetzen
 und das häufigste Element abzufragen.
\end_layout

\begin_layout Standard
Nach dem Verknüpfen mit der UI zeichnet sich ab, dass diese Lösung nicht
 funktioniert.
 Das emittieren eines Qt Signals scheint, entgegen den Erwartungen, eine
 sehr teure (im Bezug auf Laufzeit) Operation zu sein - so läuft das Bild
 perfekt flüssig, bis man ein Signal einfügt, dann ruckelt es merklich;
 nämlich immer dann, wenn ein Signal emittiert wird.
 Außerdem stürzt die Anwendung ohne jegliche Fehlermeldung ab wenn zuviele
 Signale in kurzer Zeit emittiert werden.
 Die Tatsache, dass hier keine Python Exception geworfen wird, aber auch
 der Hauptthread nicht korrekt 
\begin_inset Quotes gld
\end_inset

durchläuft
\begin_inset Quotes grd
\end_inset

 sondern einfach schließt, lässt auf einen Fehler in der C/C++ Ebene von
 Qt schließen.
 Ein grundsätzlicher Workaround wäre, einen 
\emph on
sleep
\emph default
 von 1-2s nachdem ein Signal emittiert wurde einzubauen oder die Sensitivität
 herunter zu stellen (also höherer Wert).
 Da in der Anwendung i.d.R.
 nicht nötig ist, innerhalb weniger Sekunden viele Codes einzuscannen wäre
 das auch erstmal akzeptabel und funktionell - jedoch nicht sonderlich elegant
 da das Bild in dieser Zeit immer stillstehen würde.
\end_layout

\begin_layout Standard
Dank des modularen Designs bieten sich einige bessere Möglichkeiten um dieses
 Problem zu beheben:
\end_layout

\begin_layout Itemize
Weiterer Thread, sodass ein Thread nur Bilddaten verarbeitet und ein weiterer
 nur Barcodes
\end_layout

\begin_layout Itemize
Die Qt 
\emph on
QApplication
\emph default
 auf eine nicht-blockierende Art starten und eine eigene Eventloop für die
 UI implementieren, um eine performantere Kommunikation zwischen UI und
 Sync selbst zu implementieren.
\end_layout

\begin_layout Standard
Umgesetzt wird die erste Variante.
 Dies ist mit nur geringfügigen Änderungen (weiteres Attribute der 
\emph on
VideostreamUISync
\emph default
 Klasse, zwei Verzweigungen und weitere Instanziierung der Synchronisation)
 möglich und erzielt das gewünschte Ergebnis.
\end_layout

\begin_layout Subsection
Datenbanksynchronisation
\end_layout

\begin_layout Standard
Im Modul 
\emph on
slots
\emph default
 existieren Fabrikfunktionen für die meisten Entitätsklassen der Datenbank.
 Um diese direkt bei ihrer Erzeugung mit der Datenbank zu synchronisieren,
 wird die recht simple Funktion 
\emph on
save_to_db
\emph default
 implementiert.
 Diese Funktion wird zunächst am Ende jeder Funktion, die eine neue Instanz
 erzeugt, aufgerufen.
 Dies ist zwar grundsätzlich nicht falsch, bedeutet jedoch, dass ein Programmier
er, beim späteren Pflegen des Programms, sich eventuell nur die Funktionsschnitt
stelle ansieht und dabei übersieht, dass die Instanz direkt synchronisiert
 wird.
 Daher wurde, im Zuge des Refactoring, der 
\emph on
Function-Decorator synchronized
\emph default
 geschrieben, welcher direkt bei Funktionsdefinition klarmacht, dass diese
 Funktion synchronisierte Instanzen erzeugt.
\end_layout

\begin_layout Standard
Der Function-Decorator sei hier kurz erläutert:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/synchronized.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Definition des Function-Decorators
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dekoratoren sind Konstrukte der Metaprogrammierung, die aus dem Programmierparad
igma der funktionalen Programmierung stammen.
 Ihre Daten sind andere Funktionen, Klassen etc.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "16.01.19 - 17:00 Uhr"
key "Decorators1"
literal "false"

\end_inset

 und 
\begin_inset CommandInset citation
LatexCommand cite
after "16.01.19 - 17:04 Uhr"
key "Decorators2"
literal "false"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Ein Function-Decorator ist so aufgebaut, dass er mit der @-Syntax, die ihm
 nachgestellte Funktion
\begin_inset Foot
status open

\begin_layout Plain Layout
Hier sei gesagt, dass Function-Decorator auch auf anderen aufrufbare Objekten
 arbeiten können und selbst durch verschiedene aufrufbare Objekte (
\emph on
callable
\emph default
 im Python Jargon) dargestellt werden können (z.B.
 eine Klasse die 
\emph on
__call__
\emph default
 implementiert).
 Außerdem müssen Dekoratoren nicht zwangsläufig Funktionen zurückgeben -
 sie unterliegen keinerlei Einschränkungen im Bezug auf Parameter und Rückgabewe
rten.
 Jedoch sind sie in der Form Funktion-dekoriert-Funktion-und-gibt-Funktion-zurüc
k am Häufigsten anzutreffen.
\end_layout

\end_inset

 als ersten positionellen Parameter übergeben bekommt und diese mit seiner
 Rückgabe zum Definitionszeitpunkt der dekorierten Funktion redefiniert.
 In der Schnittstelle gibt es außerdem noch 
\emph on
decorated
\emph default
, ein standardmäßig mit 
\emph on
False
\emph default
 vorbelegtes Flag, das später wichtig wird, sowie die Parameter 
\emph on
*args
\emph default
 und 
\emph on
**kwargs
\emph default
.
 Diese Parameter haben eine besondere Bedeutung, welche sie nicht durch
 ihren Namen, sondern durch die vorgestellten Asteriske erhalten (die Bezeichner
 nach * und ** sind grundsätzlich egal, jedoch sind 
\emph on
args
\emph default
 und 
\emph on
kwargs
\emph default
 gängig für 
\begin_inset Quotes gld
\end_inset

Durchreichungen
\begin_inset Quotes grd
\end_inset

, da sie in diesem Funktionskontext keine weniger abstrakte Bedeutung haben);
 
\emph on
*args
\emph default
 ist ein Parameter, welcher stellvertretend für beliebig viele positionelle
 Argumente steht - **kwargs hingegen steht für beliebig viele Schlüsselwortparam
eter  (daher der Name kwargs, von keyword arguments).
 Im Funktionskörper stellen diese dann ein Tupel bzw.
 ein Dictionary dar.
\end_layout

\begin_layout Standard
Wird diese Funktion nun das erste Mal aufgerufen, nämlich wenn die dekorierte
 Funktion definiert wird, fällt das 
\emph on
decorated
\emph default
-Flag auf seinen Standardwert 
\emph on
False
\emph default
 zurück, was zur Folge hat, dass der erste if-Block direkt betreten wird.
 In diesem wird nun die Funktion definiert, welche bei späterem Aufruf der
 Originalfunktion, an Stelle dieser aufgerufen wird.
 Die Funktion 
\emph on
partial
\emph default
 des Moduls 
\emph on
functools
\emph default
 der Standardbibliothek erlaubt die partielle Evaluation einer Funktion,
 dabei übergibt man ihr zuerst die Funktion, welche partiell evaluiert werden
 soll, und anschließend alle Parameter, welche sozusagen 
\begin_inset Quotes gld
\end_inset

vorbelegt
\begin_inset Quotes grd
\end_inset

 werden.
 Hierbei sagen wir also, dass die zurückgegebene Funktion der Decorator
 selbst ist, welcher bei jedem Aufruf implizit die dekorierte Funktion übergeben
 bekommt.
 Desweiteren setzen wir das decorated-Flag auf True.
\end_layout

\begin_layout Standard
Wird nun die dekorierte Funktion  (in ihrem dekorierten Zustand) aufgerufen,
 wird die Funktion 
\emph on
function
\emph default
  (also die dekorierte Funktion in undekoriertem Zustand) aufgerufen, wobei
 als Parameter nach der Partiellevaluation nur noch 
\emph on
args
\emph default
 und 
\emph on
kwargs
\emph default
 übrig sind.
 Hier wird beim Aufruf explizites 
\emph on
Tuple Unpacking
\emph default
 für 
\emph on
args
\emph default
 und
\emph on
 Dictionary Unpacking
\emph default
 durch die *- bzw.
 **-Syntax eingesetzt, was dazu führt, dass die Originalfunktion effektiv
 einen 
\begin_inset Quotes gld
\end_inset

normalen
\begin_inset Quotes grd
\end_inset

 Funktionsaufruf 
\begin_inset Quotes gld
\end_inset

erlebt
\begin_inset Quotes grd
\end_inset

.
 Die dadurch erzeugte Instanz kann nun weiterverarbeitet werden, bevor sie
 an den ursprünglichen Funktionsaufruf zurückgegeben wird.
\end_layout

\begin_layout Standard
In einer weiteren Verbesserungsiteration konnte die Funktion immens vereinfacht
 werden:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/synchronized_new.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verbesserte Definition des Function-Decorators
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Verzicht auf den rekursiven, partiell evaluierten Aufruf des Dekorators,
 welcher durch die Definition einer Funktion im Funktionskörper des Dekorators
 ersetzt wird, macht den Code wesentlich klarer.
 Die grundsätzliche Funktionsweise, bleibt abseits dessen jedoch gleich.
\end_layout

\begin_layout Section
Benutzerverwaltung
\end_layout

\begin_layout Standard
Da es in der Anwendung unter anderem darum geht, festzulegen, wer für welche
 Geräte verantwortlich ist, haben wir die Entscheidung getroffen, dass es
 nicht möglich sein sollte, die Verantwortlichkeiten eines anderen Mitarbeiters
 bearbeiten zu können.
 Dies erfordert ein Nutzersystem mit entsprechender Nutzerverwaltung.
 Aufgrund dieser Nutzerverwaltung wurden wir mit dem Problem konfrontiert,
 dass die Benutzer sich authentifizieren können müssen, hierfür wurde, klassisch
erweise, ein Passwort-System gewählt.
 Dies bringt das Problem der Passwortspeicherung mit sich, das, auch heute
 noch, in vielen Systemen eine Schwachstelle für potentielle Angriffe Dritter
 darstellt.
 Während es sich bei diesem System nicht um eine wirklich sicherheitskritische
 Anwendung handelt, sollte eine Anwendung unserer Ansicht nach dennoch so
 gestaltet sein, dass sie keine zu offensichtlichen Schwachstellen hat.
 Ein weiteres Problem entsteht dadurch, dass eine SQL-Datenbank im Hintergrund
 mit vom Nutzer zur Laufzeit eingegebenen Daten befüllt wird.
 Dies könnte, wenn nicht richtig abgefangen zur SQL-Injection genutzt werden.
\end_layout

\begin_layout Subsection
SQL
\end_layout

\begin_layout Standard
Das zweite Problem lässt sich mit Python vergleichsweise leicht umgehen,
 indem man beim Nutzen von 
\emph on
sqlite3
\emph default
 die mitgelieferte ?-Syntax einsetzt, oder aber, wie wir, das bereits näher
 erläuterte SQLAlchemy nutzt, welches intern eine Validierung der Werte
 durchführt, die es in seinen SQL-Befehlen nutzt.
\end_layout

\begin_layout Standard
Um das Problem/Prinzip der SQL-Injection aufzuzeigen, folgt hier ein kurzes
 Beispiel.
\end_layout

\begin_layout Standard
Gegeben sei eine sehr einfache Datenbank, die Nutzer mit Namen speichert:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Beispielprogramme/SQL-Injection/DB.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Wobei es möglich sein soll neue Nutzer über eine Kommandozeileneingabe des
 Namens hinzuzufügen.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/SQL-Injection/SQL-Injection.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von SQL-Injection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wird nun über die Kommandozeile als Name z.B.
 '""); DROP TABLE users;--' eingegeben, wird die Tabelle aller Nutzer gelöscht.
 Korrekt umgesetzt ist das Ganze in 
\emph on
insert_user_secure
\emph default
 dargestellt.
 In diesem Fall wirft dieselbe Eingabe einen Fehler und die Datenbank wird
 nicht kompromittiert.
\end_layout

\begin_layout Subsection
Kryptografie
\end_layout

\begin_layout Standard
Für die Passwörter gestaltet sich das Ganze nicht ganz so unkompliziert.
 Aufgrund dessen, dass der Quellcode offen ist und auch die Datenbank lokal
 liegt, ist es einem Angreifer ein Leichtes, jede eventuelle einfache Verschlüss
elung zu umgehen.
 Daher werden bei unserer Lösung die Passwörter gar nicht gespeichert -
 stattdessen wird ein Hash-Algorithmus (zu Deutsch: Streuwertfunktion) eingesetz
t und dieser Hash gespeichert.
 Ein Hash-Algorithmus ist eine Funktion, welche, idealerweise, in eine Richtung
 sehr schnell durchzuführen ist, in die andere dagegen einen sehr hohen
 Rechenaufwand benötigt.
 Im Idealfall ist dieser Rechenaufwand so hoch, dass sich eine 
\begin_inset Quotes eld
\end_inset

Einwegfunktion
\begin_inset Quotes erd
\end_inset

 ergibt, die nicht umzukehren ist.
 Ein klassisches Beispiel für einen simplen Hash-Algorithmus ist die einstellige
 Quersumme, hier wird rekursiv die Quersumme einer Zahl gebildet, bis nur
 noch eine Stelle übrig ist.
\end_layout

\begin_layout Subsubsection
Benutzer anlegen
\end_layout

\begin_layout Standard
Das genaue Verfahren ist im folgenden Diagramm ersichtlich, der zugehörige
 Quellcode ist in der Klasse 
\emph on
User 
\emph default
als Methode 
\emph on
hash
\emph default
 zu finden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/User-Anlegen-Prozess.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Passwort-Speicher-Vorgang
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es werden also aus den vom Nutzer getätigten Eingaben der Benutzername und
 das Passwort ausgewählt  (bzw.
 werden diese in der Instanz einer Nutzerklasse abgelegt und daraus wieder
 abgerufen, dies wird allerdings später näher erläutert).
 Außerdem wird eine kryptografisch starke  (im Gegensatz zu den, nicht für
 Kryptografieanwendungen geeigneten Zufallszahlen des normalen Pythonmoduls
 
\emph on
random
\emph default
) 256-Bit Zufallszahl generiert.
 Diese stellt ein erstes Salt dar.
 Im ersten Schritt wird nun die E-Mail-Adresse - ein String also - zu einer
 Abfolge aus Bytes codiert, welche dann als Ganzzahl interpretiert wird.
 Diese Zahl wird anschließend über ein logisches XOR mit dem generierten
 Salt verknüpft und stellt unser finales Salt dar.
 Die daraus resultierende Zahl sowie das Passwort werden dann wieder zu
 einer Folge aus Bytes konvertiert.
 Im zweiten Schritt werden nun diese beiden 
\emph on
bytes
\emph default
-Instanzen über einen PBKDF2-Algorithmus miteinander verknüpft.
 In unserem Fall nutzt dieser intern einen HMAC-, welcher wiederum einen
 SHA-512-Algorithmus nutzt.
 Dieser Hash-Vorgang wird nun 9600-mal durchgeführt.
 Der daraus entstehende Hash ist unser 
\begin_inset Quotes eld
\end_inset

Endergebnis
\begin_inset Quotes erd
\end_inset

 und wird zusammen mit der Anfangs generierten Zufallszahl in der Datenbank
 abgelegt.
\end_layout

\begin_layout Standard
Der Hintergrund zu der vergleichsweise komplexen Erzeugung des finalen Salts
 ist Folgender:
\end_layout

\begin_layout Itemize
Wenn man kein Salt einsetzt, haben zwei Nutzer in der Datenbank denselben
 Hash, wenn sie dasselbe Passwort haben, was einem Angreifer im Bereich
 Social Engineering einen Angriffspunkt liefern würde  (à la.: 
\begin_inset Quotes eld
\end_inset

Was haben diese Nutzer gemeinsam, dass sie eventuell als Passwort nutzen
 könnten
\begin_inset Quotes erd
\end_inset

), bzw.
 lässt auf ein gängiges Passwort schließen.
\end_layout

\begin_layout Itemize
Wenn man nur die Zufallszahl als Salt nutzt, ist es theoretisch möglich,
 dass zwei Nutzer dieselbe Zufallszahl erhalten  (Auch wenn diese Wahrscheinlich
keit praktisch vernachlässigbar klein ist, bei 
\begin_inset ERT
status open

\begin_layout Plain Layout

$2^{256}$
\end_layout

\end_inset

 Werten, die die Zufallszahl annehmen kann und einer zu erwartenden Nutzerzahl
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
leq$
\end_layout

\end_inset

 50) was im selben Problem wie der zuvor genannte Punkt münden würde.
\end_layout

\begin_layout Itemize
Wenn man nur den Benutzernamen als Salt einsetzt läuft man Gefahr, dass
 ein Nutzer einen sehr kurzen Benutzernamen wählt, wodurch ein vergleichsweise
 schnelles Durchprobieren/ Brute-Forcen durch alle Salts möglich ist.
\end_layout

\begin_layout Itemize
Durch die XOR-Verknüpfung von Nutzername und Zufallszahl hat man somit ein
 für jeden Nutzer garantiert einzigartiges Salt.
 Ein Angreifer kann dadurch eine Bruteforce Attacke nur für einen einzigen
 Nutzer auf einmal ausführen.
\end_layout

\begin_layout Subsubsection
Benutzer anmelden
\end_layout

\begin_layout Standard
Beim Anmeldevorgang wird grundsätzlich derselbe Vorgang wie beim Erzeugen
 eines Nutzers durchgeführt, nur dass hier aus der Datenbank abgefragt,
 anstatt gespeichert wird.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/User-Anmelden-Prozess.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Anmelde-Vorgang
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Nutzer gibt also wieder seine Daten ein.
 Anhand des Nutzernamens wird nun geprüft, ob ein solcher Nutzer in der
 Datenbank vorhanden ist - wenn ja, wird dieser ausgelesen.
 Nun wird mit dem ausgelesenen Salt analog zum Passwort-Speicher-Vorgang
 ein Hash erzeugt.
 Stimmt dieser Hash mit dem des Nutzers aus der Datenbank überein, wird
 der Benutzer eingeloggt.
\end_layout

\begin_layout Subsubsection
Benutzer hat sein Passwort vergessen
\end_layout

\begin_layout Standard
Wenn man ein System errichtet, bei dem ein Nutzer sich ein Passwort merken
 muss, ist die Wahrscheinlichkeit groß, dass er dieses vergisst.
 Daher gibt es einen Prozess, um das Passwort eines Nutzers zurücksetzen
 zu können.
 Da die Anwendung grundsätzlich offline laufen können sollte  (nicht zuletzt
 aus sicherheitstechnischen Aspekten), wurde hier nicht die Variante des
 Rücksetzens per E-Mail-Token gewählt - stattdessen gibt es einen  (oder
 auch mehrere) Admin-User die dem Nutzer ein automatisch generiertes Passwort
 zuweisen können, sodass er sich anmelden und selbst ein neues eingeben
 kann.
 Dieser Prozess lässt sich wie folgt visualisieren:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/User-PW-Reset.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Rücksetzen eines Benutzerpassworts
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird also zunächst, über eine Nutzereingabe, der gewünschte User aus
 der Datenbank ausgelesen.
 Parallel dazu wird aus einer vordefinierten Zeichenfolge eine Auswahl von
 15 Zeichen getroffen.
 Diese stellen das neue Passwort dar und werden in der UI angezeigt.
 Bei der Zeichenfolge, aus der das Passwort generiert wird, wird darauf
 geachtet, dass jedes Zeichen klar lesbar ist.
 So wurden 
\begin_inset Quotes eld
\end_inset

O
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

l
\begin_inset Quotes erd
\end_inset

 ausgenommen da diese nicht immer klar zu unterscheiden bzw.
 leicht zu verwechseln sind.
 Abseits davon besteht die Zeichenfolge aus dem ganzen Alphabet in Groß-
 und Kleinschreibung, den Ziffern und einigen Sonderzeichen - insgesamt
 stehen somit 77 Zeichen zur Verfügung.
 Es stellt sich die Frage, ob es klüger wäre mehr Zeichen hinzuzufügen oder
 aber ein längeres Passwort zu wählen.
\end_layout

\begin_layout Subsubsection
Mathematische Betrachtung der Passwort-Generation
\end_layout

\begin_layout Standard
Definiert man 
\emph on
n
\emph default
 als die Anzahl an verfügbaren Zeichen und 
\emph on
k
\emph default
 als Länge des Passwortes lässt sich die Anzahl an möglichen Passwörtern
 mit der Funktion 
\begin_inset ERT
status open

\begin_layout Plain Layout

$$f (n,k) := n^k$$
\end_layout

\end_inset

 darstellen.
 Möchte man nun wissen, ob es effizienter ist, weitere Zeichen hinzuzufügen
 oder das Passwort zu verlängern, kann man dies über eine Betrachtung der
 beiden partiellen Ableitungen
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$f_1 (n,k) := 
\backslash
frac {
\backslash
partial f}{
\backslash
partial n} = k 
\backslash
cdot n^{k-1}$$
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
und 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$f_2 (n,k) := 
\backslash
frac {
\backslash
partial f}{
\backslash
partial k} = 
\backslash
frac{
\backslash
partial}{
\backslash
partial k} e^{ln(n^k)} = 
\backslash
frac{
\backslash
partial}{
\backslash
partial k} e^{k 
\backslash
cdot ln(n)} = e^{k 
\backslash
cdot ln(n)} 
\backslash
cdot ln(n) = n^k 
\backslash
cdot ln (n)$$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
herausfinden.
 Diese beschreiben die Änderungsraten von 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f (n,k)$
\end_layout

\end_inset

 bei Änderung eines der beiden Parameter.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Passwort-Varianten-Graph_1_cropped.png
	scale 35

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Vergleich von 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_1$
\end_layout

\end_inset

 und 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_2$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hier wurden die beiden Funktionen für die Werte 5, 10 und 15 für den Parameter,
 welcher statisch gehalten wird  (k bei 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_1$
\end_layout

\end_inset

 und n bei 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_2$
\end_layout

\end_inset

; dargestellt durch i), und in einem Bereich von 0 bis 20 des dynamischen
 Parameters geplottet.
 Wie man sieht, gibt es sowohl Bereiche, in denen 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_1$
\end_layout

\end_inset

, wie auch welche, in denen 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_2$
\end_layout

\end_inset

 effizienter (sprich größer) ist (siehe Schnittpunkte der Graphen).
 Daher sollte man eine allgemeinere Darstellung wählen.
 Verallgemeinert, sodass kein Parameter statisch gehalten wird, lässt sich
 die Funktion folgendermaßen darstellen:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Passwort-Varianten-Graph_2_cropped.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Heatmap aus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_1$
\end_layout

\end_inset

 und 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_2$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn man eine neue Funktion 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_3 (n, k)$
\end_layout

\end_inset

 als 
\begin_inset ERT
status open

\begin_layout Plain Layout

$$f_3 (n, k) := f_1 - f_2 = 
\backslash
frac {
\backslash
partial f}{
\backslash
partial n} - 
\backslash
frac {
\backslash
partial f}{
\backslash
partial k} = k 
\backslash
cdot n^{k-1} - n^k 
\backslash
cdot ln (n)$$
\end_layout

\end_inset

 definiert, und bei dieser alle Werte > 0 in Schwarz, die anderen in Weiß
 darstellt, hat man eine Karte, die angibt, ob bei einer bestimmten Koordinate
 die Erhöhung von k oder n die effizientere Wahl ist, um das generierte
 Passwort sicherer zu machen.
 Die Grenze zwischen den weißen und schwarzen Bereichen stellt die Nullstellen
 von 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_3$
\end_layout

\end_inset

 dar.
 Setzt man also 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_3 = 0$
\end_layout

\end_inset

 und löst dieses beispielsweise nach k auf ergibt sich 
\begin_inset ERT
status open

\begin_layout Plain Layout

$$k 
\backslash
cdot n^{k-1} - n^k 
\backslash
cdot ln (n) = 0$$ mit Subtraktion von $n^k 
\backslash
cdot ln (n)$ folgt
\end_layout

\begin_layout Plain Layout

$$n^k 
\backslash
cdot ln(n) = k 
\backslash
cdot n^{k-1}$$ Division durch $n^{k-1}$ liefert
\end_layout

\begin_layout Plain Layout

$$
\backslash
frac{n^k}{n^{k-1}} 
\backslash
cdot ln(n) = k$$ 
\end_layout

\begin_layout Plain Layout

$$n^{k-(k-1)} 
\backslash
cdot ln(n) = k$$
\end_layout

\begin_layout Plain Layout

$$k = n 
\backslash
cdot ln(n)$$ Was letztendlich unser Ergebnis darstellt
\end_layout

\begin_layout Plain Layout

$$k (n) = n 
\backslash
cdot ln (n)$$
\end_layout

\end_inset

, was ein einfacheres Überprüfen der Koordinaten zulässt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Passwort-Varianten-Graph_3_cropped.png
	scale 40
	clip

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

$k (n)$
\end_layout

\end_inset

 aus 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_3$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hier gilt, dass bei einem Punkt oberhalb der Kurve der Wert von 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_3$
\end_layout

\end_inset

 positiv ist, wohingegen er unterhalb negativ ist.
 Daraus folgt, dass oberhalb der Kurve 
\begin_inset ERT
status open

\begin_layout Plain Layout

$f_1$
\end_layout

\end_inset

 überwiegt, also die Rate der Änderung von k größer der von n ist.
\end_layout

\begin_layout Standard
Basierend auf diesen Daten bzw.
 Feststellungen wurde also der Zeichensatz um einige Zeichen erweitert.
 Es stehen nun 84 anstatt 77 Zeichen zur Verfügung, also 7 Zeichen mehr.
 Diese 7 Zeichen mehr geben bei gleicher Passwortlänge von 15 Zeichen 
\begin_inset ERT
status open

\begin_layout Plain Layout

$84^{15}-77^{15} 
\backslash
approx 7,31 
\backslash
cdot 10^{28} - 1.98 
\backslash
cdot 10^{28} = 5.33 
\backslash
cdot 10^{28}$
\end_layout

\end_inset

 mehr Möglichkeiten.
 Oder anders ausgedrückt ist die Sicherheit des Passworts um den Faktor
 3,69 erhöht worden.
\end_layout

\begin_layout Standard
Im Retrospekt ist zu erkennen, dass hierbei eine Funktion für die Schnittpunkte
 der beiden partiellen Ableitungen gebildet wurde.
\end_layout

\begin_layout Subsubsection
Admin hat sein Passwort vergessen
\end_layout

\begin_layout Standard
Allerdings kann es auch vorkommen, dass ein Admin sein Passwort vergisst
 - auch für so einen Fall steht ein Prozess zur Verfügung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Admin-PW-Reset.png
	scale 50
	clip

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Verifizierung zum Rücksetzen eines Admin-Passworts 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn ein Admin sein Passwort zurücksetzen möchte, so erfordert dies eine
 weitere Sicherheitsstufe.
 Diese wird über eine asymmetrische Verschlüsselung mittels RSA, bzw.
 PKCS #1-OAEP realisiert.
 Das Verfahren läuft dabei wie folgt ab:
\end_layout

\begin_layout Itemize
Lokal ist ein Public-Key hinterlegt
\end_layout

\begin_layout Itemize
Mit diesem wird ein arbiträrer Wert  (In der Implementierung ist 
\begin_inset Quotes eld
\end_inset

True
\begin_inset Quotes erd
\end_inset

 gewählt) verschlüsselt
\end_layout

\begin_layout Itemize
Anschließend wird probiert diesen Wert mit einem vom Nutzer gegebenen Schlüssel
 zu entschlüsseln
\end_layout

\begin_layout Itemize
Ist dies erfolgreich, wird ein neues Schlüsselpaar erzeugt und sowohl Public-
 wie auch Private-Key überschrieben - dies hat zur Folge, dass jedes Schlüsselpa
ar nur einmal gültig ist - so können andere Admins kontrollieren, ob ein
 Admin kürzlich sein Passwort zurückgesetzt hat
\end_layout

\begin_layout Itemize
Ab hier wird der normale Passwort-Rücksetz-Vorgang eines Users eingeleitet
\end_layout

\begin_layout Standard
Es ist so vorgesehen, dass ein Admin  (bzw.
 Superadmin - je nachdem, wer Zugang zum Private-Key erhält) den Schlüssel
 auf einem USB-Stick o.ä.
 ablegt und diesen im Bedarfsfall einsteckt.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Automatisches-Abmelden"

\end_inset

Automatisches Abmelden
\end_layout

\begin_layout Standard
Bei einem zentralen System, das mehreren Nutzern zugänglich ist, ist es
 wünschenswert, wenn ein Nutzer automatisch abgemeldet wird, sobald er eine
 bestimmte Zeit untätig ist.
 Dies beugt Missbrauch vor.
 Hierzu wurde die Klasse 
\emph on
Timeout
\emph default
 geschrieben.
\end_layout

\begin_layout Standard

\emph on
Timeout
\emph default
 ermöglicht es, einen Thread zu öffnen, welcher im Hintergrund mit einer
 bestimmten Abtastrate
\begin_inset Marginal
status open

\begin_layout Plain Layout
td: Abtastrate ist nicht aktuell
\end_layout

\begin_layout Plain Layout
es wird bei theoretischem timeout überprüft ob ein reset erfolgt ist =>
 Performanz
\end_layout

\end_inset

 prüft, ob die eingestellte Zeit bereits verstrichen ist.
 Da es mit dieser Funktionalität an sich nur ein Timer wäre, implementiert
 die Klasse weiterhin die Methode 
\emph on
reset
\emph default
, um den internen Timer immer dann zurückzusetzen, wenn ein bestimmtes Event
 aufgetreten ist.
 Jede 
\emph on
Timeout
\emph default
-Instanz erhält außerdem ein aufrufbares Objekt und eine Liste mit positionellen
 Argumenten.
 Beim timeout wird diese Methode mit den übergebenen Argumenten ausgeführt
 und das Attribut 
\emph on
timed_out
\emph default
 auf 
\emph on
True
\emph default
 gesetzt.
 Bei den Argumenten ist zu beachten, dass 
\emph on
args
\emph default
 standardmäßig auf None gesetzt wird, zur Laufzeit des Konstruktors allerdings
 mit einer leeren Liste ersetzt wird, wenn dieser Standardwert vorhanden
 ist.
 Dies hat den Hintergrund, dass es generell eine schlechte Idee ist, eine
 leere Liste als Standardwert festzulegen.
 Standardwerte werden nämlich nicht beim Aufrufen einer Methode  (oder Funktion
 oder Sonstigem), sondern sobald das zugehörige 
\emph on
def 
\emph default
ausgeführt wird, evaluiert.
 Bei immutablen Datentypen ist dies kein Problem, bei mutablen allerdings
 wird so stets dieselbe Instanz intern verwendet, was dazu führt, dass eine
 Änderung der Daten in einem Funktionsaufruf alle anderen mit beeinflusst.
 Des Weiteren ist hier der Vergleich auf 
\emph on
None
\emph default
 zu beachten.
 
\emph on
None
\emph default
 ist in Python ein Singleton, das stets mit 
\emph on
is anstatt mit 
\emph default
== verglichen werden sollte.
 In einer späteren Revision wurde die Klasse dahingehend abgeändert, dass
 sie auch Keyword-Arguments unterstützt.
\end_layout

\begin_layout Standard
Die Funktion die ausgeführt wird, ist eine sog.
 
\emph on
Lambda Funktion/Lambda Expression
\emph default
.
 Lambda Expressions sind anonyme Funktionen, die vorwiegend eingesetzt werden
 wenn sich der Umfang einer Funktion zu gering ist um eine Funktionsdefinition
 mit 
\emph on
def
\emph default
 zu rechtfertigen oder die Funkionsdefinition 
\emph on
inline
\emph default
 geschehen soll.
 Die eingesetzte Funktion, ist eine Funktion, welche ein 
\emph on
Signal
\emph default
 übergeben bekommt und dieses mit dem Parameter 
\emph on
True
\emph default
 emittiert.
 Dieses Signal ist ein Qt-Signal, welches soz.
 von einem 
\emph on
Slot
\emph default
 der UI abgefangen wird.
 Ein direkter Aufruf einer Methode der UI ist nicht möglich, da Qt nicht
 
\emph on
threadsafe
\emph default
 aufgebaut ist.
 Das Prinzip der Slots und Signale wird im Abschnitt über PyQt näher erläutert.
 
\end_layout

\begin_layout Standard
Da die Klasse Timeout auf paralleler Programmierung basiert, sind hier einige
 Besonderheiten zu beachten.
 So wird auf 
\emph on
timer
\emph default
 sowohl von außerhalb, über 
\emph on
reset
\emph default
, wie auch von innerhalb zugegriffen.
 Die Punkte, an denen diese Zugriffe stattfinden, bezeichnet man als 
\emph on
Critical Sections
\emph default
, hier kann es zu sog.
 
\emph on
Race Conditions
\emph default
 kommen
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "S. 565"
key "Python3"
literal "true"

\end_inset


\end_layout

\end_inset

.
 Dies ist der Fall, wenn ein Thread gerade auf die Variable zugreift (z.B.
 liest) und dann der andere Thread die Kontrolle erhält und die Variable
 überschreibt und führt dazu, dass der lesende Thread einen falschen Wert
 erhält.
 Um diesem Problem vorzubeugen existiert die Klasse 
\emph on
Lock
\emph default
 des Moduls 
\emph on
threading.

\emph default
 Mithilfe dieser lassen sich Stellen, die nicht parallel verarbeitet werden
 dürfen, abriegeln  (siehe Mutex).
 Dabei nimmt sich der Thread, welcher zuerst seine 
\emph on
Critical Section
\emph default
 erreicht, den 
\emph on
lock
\emph default
, welcher als Kontext-Manager fungiert (intern werden die Methoden lock.acquire
 und lock.release aufgerufen) und führt den Code im 
\emph on
with
\emph default
-Block aus.
 Der andere Thread kann hierbei weiterlaufen bis er seine 
\emph on
Critical Section
\emph default
 erreicht, erst dann wird er blockiert, bis er selbst den 
\emph on
lock 
\emph default
akquirieren kann.
 
\end_layout

\begin_layout Standard
Zur Parallelisierung wurde ein Thread einem Prozess gegenüber bevorzugt,
 da der Overhead hier kleiner ist, es ist also weniger kostspielig einen
 neuen Thread zu öffnen.
 Außerdem ist der Datenaustausch zwischen Threads immens einfacher verglichen
 mit Prozessen.
 In unserem Fall können wir einfach Attribute der Klasse dafür benutzen;
 bei einem Prozess müsste hier auf Kommunikation mittels 
\emph on
sockets
\emph default
, Serialisierung mit 
\emph on
pickle
\emph default
 oder temporäre Dateien zurückgegriffen werden (alternativ gibt es auch
 im Modul 
\emph on
multiprocessing
\emph default
 eine Klasse für 
\emph on
Atomic-Message Queues
\emph default
).
\end_layout

\begin_layout Standard
Abschließend ist als wichtiger Punkt zu nennen, dass es für simple Timer-Aufgabe
n die Klasse 
\emph on
Timer
\emph default
 im Modul 
\emph on
threading
\emph default
 gibt.
 Diese unterstützt jedoch weder Funktionsargumente noch das Zurücksetzen
 des Timers, er kann lediglich gänzlich abgebrochen werden.
 Außerdem bietet 
\emph on
threading
\emph default
 weitere Klassen, welche in der Implementierung von Timer hätten genutzt
 werden können.
 So hätte man das Zurücksetzen beispielsweise mit einer 
\emph on
Event
\emph default
-Instanz lösen können.
 Da dies jedoch keinen weiteren Nutzen oder bessere Performance bringt wurde
 darauf verzichtet.
\end_layout

\begin_layout Subsection

\emph on
\begin_inset CommandInset label
LatexCommand label
name "subsec:Die-Klasse-TelephoneNumber"

\end_inset


\emph default
Die Klasse 
\emph on
TelephoneNumber
\end_layout

\begin_layout Standard
Beim Ablegen einer Nutzereingabe in einer Datenbank ist es ratsam diese
 Eingabe in irgendeiner Art und Weise zu standardisieren, sodass bei einer
 anderen Eingabe die jedoch dieselben Informationen enthält, erkannt wird,
 dass der Nutzer dasselbe meint.
 Bei einer E-Mail-Adresse oder einem Namen z.B.
 ist das eine sehr einfache Aufgabe, so kann man hier einfach die übergebene
 Zeichenkette komplett in Kleinbuchstaben umwandeln.
 Bei einer Telefonnummer hingegen ist diese Standardisierung eine nontriviale
 Aufgabe, da ein Nutzer eine Telefonnummer beispielsweise mit Länderkennzahl,
 Vorwahl, Durchwahl oder auch einfach nur als lokale Nummer eingeben könnte.
 Daher wird die Nutzereingabe intern umformatiert und eventuell fehlende
 Angaben  (wie z.B.
 eine fehlende Länderkennzahl) extrapoliert, sodass jedesmal eine volle
 Nummer zur Verfügung steht.
 Sieht man sich die Norm DIN 5008 an, dann besteht eine vollständige Nummer
 aus Länderkennzahl  (country-code), Vorwahl  (area-code), Rufnummer  (subscribe
r number) und Nebenstellennummer bzw.
 Durchwahl  (extension)
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "22.12.18 - 18:02 Uhr"
key "Wiki_Rufnummer"
literal "false"

\end_inset


\end_layout

\end_inset

.
 Es gilt in der Nutzereingabe ein Muster zu erkennen, anhand dessen sich
 feststellen lässt, welche Teile der Nummer er angegeben hat und wie diese
 lauten.
 Hierbei handelt es sich um ein Paradebeispiel für Pattern-Recognition 
 (dt.
 Mustererkennung) mittels
\emph on
 regular expression
\emph default
 (dt.
 regulärer Ausdruck, kurz 
\emph on
Regex
\emph default
).
 Diese kann man in Python mit dem Modul 
\emph on
re
\emph default
 der Standardbibliothek nutzen.
 Zunächst wird also ein Muster entwickelt, dass die einzelnen Teile erkennt.
 Der Muster-String ist:
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
r"(((
\backslash
+
\backslash
d{1,3})|(0)) ?([1-9]+) )?((
\backslash
d+ ?)+)(-
\backslash
d+)?"
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Was zunächst wie eine Kette aus unzusammenhängenden Zeichen aussieht, symbolisie
rt alle syntaktischen Kombinationen die ein Nutzer zur Eingabe wählen kann,
 um dem System zu erlauben, die Telefonnummer korrekt zu erkennen.
 Der präfix 
\emph on
r
\emph default
 vor dem String gibt an, dass es sich um einen raw-String handelt - ein
 String ohne standard Escape-Sequenzen wie 
\backslash
n etc.
 also.
\end_layout

\begin_layout Standard
Eine Regex ist über die runden Klammern in Gruppen unterteilt, die jeweils
 eine Aufgabe übernehmen.
 Zu Beginn werden also drei Gruppen eröffnet, diese sind mit der Reihenfolge
 ihrer öffnenden Klammer nach als erste, zweite und dritte Gruppe benannt.
 Gruppe 3 enthält damit das erste Unterpattern.
 Hierarchisch dargestellt ließe sich die Regex so aufbauen  (Syntax in Anlehnung
 an XML):
\end_layout

\begin_layout Description
Pattern
\end_layout

\begin_deeper
\begin_layout Description
Gruppe_1
\end_layout

\begin_deeper
\begin_layout Description
Gruppe_2
\end_layout

\begin_deeper
\begin_layout Description
Gruppe_3
\end_layout

\begin_deeper
\begin_layout Description

\backslash
+ steht für das Literal +
\end_layout

\begin_layout Description

\backslash
d steht für eine beliebige Zahl zwischen 0 und 9
\end_layout

\begin_layout Description
{1,3} steht dafür, dass der vorhergehende Ausdruck mindestens einmal und
 maximal 3 mal vorkommen darf
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_3
\end_layout

\begin_layout Description
| stellt ein logisches ODER zwischen Gruppen oder Ausdrücken dar
\end_layout

\begin_layout Description
Gruppe_4
\end_layout

\begin_deeper
\begin_layout Description
0 steht für das Literal 0
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_4
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_2
\end_layout

\begin_layout Description
Leerzeichen steht für den String 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, also ein einzelnes Leerzeichen
\end_layout

\begin_layout Description
? steht dafür, dass der vorhergehende Teil entweder 0- oder 1-mal, jedoch
 nicht öfter vorkommt; mit den bisherigen Gruppen lässt sich also feststellen,
 ob eine Eingabe mit Länderkennzahl oder eine Vorwahl mit beginnender 0
 gewählt wurde oder keine von beidem vorhanden ist.
 Es kann auch sein, dass eine Leerstelle zwischen Länderkennzahl/ führender
 Null und dem Rest der Nummer steht
\end_layout

\begin_layout Description
Gruppe_5
\end_layout

\begin_deeper
\begin_layout Description
[1-9] steht für eine beliebige Zahl zwischen 1 und 9
\end_layout

\begin_layout Description
+ steht dafür, dass der vorhergehende Ausdruck mindestens einmal, möglicherweise
 jedoch beliebig oft vorkommt
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_5
\end_layout

\begin_layout Description
Leerzeichen steht für den String 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, also ein einzelnes Leerzeichen
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_1
\end_layout

\begin_layout Description
? steht dafür, dass der vorhergehende Teil entweder 0- oder 1-mal, jedoch
 nicht öfter vorkommt; mit den bisherigen Gruppen lässt sich feststellen,
 ob eine Vorwahl angegeben wurde
\end_layout

\begin_layout Description
Gruppe_6
\end_layout

\begin_deeper
\begin_layout Description
Gruppe_7
\end_layout

\begin_deeper
\begin_layout Description

\backslash
d steht für eine beliebige Zahl zwischen 0 und 9
\end_layout

\begin_layout Description
+ steht dafür, dass der vorhergehende Ausdruck mindestens einmal, möglicherweise
 jedoch beliebig oft vorkommt
\end_layout

\begin_layout Description
Leerzeichen steht für den String 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

, also ein einzelnes Leerzeichen
\end_layout

\begin_layout Description
? steht dafür dass der vorhergehende Teil entweder 0- oder 1-mal, jedoch
 nicht öfter vorkommt
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_7
\end_layout

\begin_layout Description
+ steht dafür, dass der vorhergehende Ausdruck mindestens einmal, möglicherweise
 jedoch beliebig oft vorkommt
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_6 bisher lässt sich feststellen, ob eine Vorwahl gegeben wurde und
 ob eine Rufnummer vorhanden ist - die umschließende Gruppe 6 matched alle
 Gruppe 7 Iterationen
\end_layout

\begin_layout Description
Gruppe_8
\end_layout

\begin_deeper
\begin_layout Description
- steht für das Literal -
\end_layout

\begin_layout Description

\backslash
d steht für eine beliebige Zahl zwischen 0 und 9
\end_layout

\begin_layout Description
+ steht dafür, dass der vorhergehende Ausdruck mindestens einmal, möglicherweise
 jedoch beliebig oft vorkommt
\end_layout

\end_deeper
\begin_layout Description
/Gruppe_8
\end_layout

\begin_layout Description
? steht dafür dass der vorhergehende Teil entweder 0- oder 1-mal, jedoch
 nicht öfter vorkommt; Hiermit wird geprüft ob eine Durchwahl angegeben
 wurde
\end_layout

\end_deeper
\begin_layout Description
/Pattern
\end_layout

\begin_layout Standard
Mittels 
\emph on
re.compile,
\emph default
 mit gesetztem 
\emph on
re.DEBUG
\emph default
 Flag, lässt sich außerdem folgende, die Regex beschreibende Ausgabe erzeugen:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/regex.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Kompilierung und Debugausgabe der Regular Expression
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auf diese Ausgabe sei hier nicht näher eingegangen.
 Im Code selbst findet sich die Kompilierung nicht wieder.
 Sie ist nicht nötig, da die Funktionen von 
\emph on
re
\emph default
 so implementiert sind, dass sie die übergebenen patterns intern kompilieren
 und cachen.
 Wenn nicht sehr viele verschiedene patterns genutzt werden, kann daher
 auf dieses Cache zurückgegriffen werden.
 Dies hat den Vorteil, dass die Kompilierung nur stattfindet, wenn sie tatsächli
ch nötig ist und außerdem pro Session maximal einmal.
\end_layout

\begin_layout Standard
Dieses Pattern ist als Klassenvariable der Klasse TelephoneNumber hinterlegt.
 Wird nun TelephoneNumber instanziiert, so wird über 
\emph on
re.search
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Alternativ könnte man hier 
\emph on
re.match
\emph default
 nutzen.
 Der Unterschied ist, dass 
\emph on
re.search
\emph default
 den gesamten String durchsucht, während 
\emph on
re.match
\emph default
 lediglich den Anfang betrachtet.
\begin_inset CommandInset citation
LatexCommand cite
after "01.03.19 - 19:32 Uhr"
key "re"
literal "false"

\end_inset


\end_layout

\end_inset

 zunächst ermittelt ob im übergebenen String - also der Nutzereingabe -
 eine Telefonnummer ist, die auf das Pattern passt.
 Sofern dies nicht der Fall ist, wird ein Fehler geworfen.
 Andernfalls werden die einzelnen Gruppen ausgewertet und als Attribute
 der Instanz hinterlegt.
 So ist der Ländercode beispielsweise durch Gruppe 2 vertreten.
 Es wird überprüft, ob Gruppe zwei ein + enthält, wenn dies der Fall ist,
 wird der 
\emph on
_whitespacekiller
\emph default
 aufgerufen, eine statische Methode die alle Zeichen die keine Zahlen sind,
 aus der Kette entfernt  (hier kommt eine weitere Regex zum Einsatz, diese
 ist jedoch so trivial, dass auf eine Erklärung verzichtet wird).
 Sofern kein + vorhanden ist, wird direkt 049 zurückgegeben, da davon ausgegange
n werden kann, dass es sich in diesem Fall um eine deutsche Nummer handelt.
 Ähnlichen Verfahren folgend werden dann die Gruppen 5, 6 und 8 für Vorwahl,
 Rufnummer und Durchwahl ausgewertet.
\end_layout

\begin_layout Standard
Nach dieser grundsätzlich funktionellen Implementierung, wird die komplette
 Regex noch mit Hinblick auf bessere Les- und Wartbarkeit abgeändert.
 Die resultierende Regex sieht wie folgt aus:
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
r"(?P<prelude>(?P<country_code>(?:
\backslash
+
\backslash
d{1,3})|(?:0)) *(?P<area_code>(?:[1-9])+) )?(?P<subscriber_number>(?:
\backslash
d+ ?)+)(?P<extension>[-
\backslash
+]
\backslash
d+)?"
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Die zu Grunde liegende Funktion bleibt die Gleiche, jedoch gibt es einige
 entscheidende Vorteile:
\end_layout

\begin_layout Enumerate
Untergruppen die selbst nicht angesprochen werden müssen, werden mit 
\emph on
(?:...) 
\emph default
unterdrückt (macht sich im Kompilat durch 
\emph on
None
\emph default
s an Subpatterns bemerkbar)
\end_layout

\begin_layout Enumerate
Einzelbestandteile/Gruppen werden mit 
\emph on
(?P<name>...)
\emph default
 benannt.
 Sollte zu einem späteren Zeitpunkt eine Änderung, die Gruppen hinzufügt
 oder entfernt erfolgen, so werden die einzelnen Teile weiterhin korrekt
 erkannt (z.B.
 war die Durchwahl in der ursprünglichen Regex unter Gruppe 8 zu finden).
 Python erlaubt die Abfrage von benannten Gruppen über die selbe Schnittstelle
 (
\emph on
group
\emph default
-Methode einer Match-Instanz) - für benannte Gruppen wird einfach die Gruppenbez
eichnung übergeben.
\end_layout

\begin_layout Standard
Die Gruppen sind also:
\end_layout

\begin_layout Description
prelude Umfasst der Rufnummer vorgestellte Segmente
\end_layout

\begin_layout Description
country_code Umfasst Länderkennzahl
\end_layout

\begin_layout Description
area_code Umfasst Vorwahl
\end_layout

\begin_layout Description
subscriber_number Umfasst Rufnummer
\end_layout

\begin_layout Description
extension Umfasst Durchwahl
\end_layout

\begin_layout Standard
Desweiteren implementiert die Klasse die Magic Methods 
\emph on
__str__ 
\emph default
und 
\emph on
__format__
\emph default
, welche ermöglichen eine Instanz als String zu evaluieren.
 Hierbei wird die Telefonnummer als vollständige DIN 5008-konforme Nummer
 zurückgegeben.
 Über 
\emph on
__format__
\emph default
 ist es möglich, die Instanz direkt in f-Strings o.Ä.
 einzubinden und die bekannten Formatspecifier für Strings zu nutzen.
\end_layout

\begin_layout Standard
Die Klasse besitzt außerdem eine von 
\emph on
Warning
\emph default
 abgeleitete Klasse, die sie emmitiert, wenn sie keine Nummer finden kann.
\end_layout

\begin_layout Standard
Durch diese ausgefeilte Implementierung des Telefonnummernextrahierens kann
 der Nutzer seine Telefonnummer, wenn er denn möchte, auch in einem Satz
 verpacken o.ä., sie wird dennoch fehlerfrei erkannt.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
PyQt5
\end_layout

\begin_layout Standard
Bei PyQt5 handelt es sich um ein GUI-Toolkit und Framework für Python.
 Grundsätzlich handelt es sich um einen Wrapper des Qt  (lies 
\begin_inset Quotes eld
\end_inset

cute
\begin_inset Quotes erd
\end_inset

, oftmals jedoch auch Q-T (englisch)) Frameworks für C++.
 Was Qt und PyQt seine Attraktivität, auch im professionellen, Bereich verleiht,
 ist vor allem, dass eine Qt-Anwendung grundsätzlich Cross-Platform ist
 und dabei auf allen Plattformen konsistent gut aussieht.
\end_layout

\begin_layout Subsection
Darstellen der Verantwortlichkeiten als Baumstruktur
\end_layout

\begin_layout Standard
Aufgrund von guter Übersichtlichkeit haben wir uns dazu entschlossen die
 Verantwortlichkeiten als Baumstruktur darzustellen.
 PyQt5 stellt hierzu die Widgets QTreeView und QTreeWidget zur Verfügung,
 wobei QTreeView ein Model-View-Architektur- und QTreeWidget ein Item-basierende
s Widget ist.
 Die MV-Architektur die PyQt über einige, teils abstrakte, Klassen bietet,
 ist dabei eine Variante der generell bekannten Model-View-Controller-Architektu
r, wobei der Controller mit dem View kombiniert wurde.
 Desweiteren wurde in PyQt der Delegate hinzugefügt, der managt, wie Daten
 im View gerendert werden und wie geänderte Daten der UI im Model abgelegt
 werden.
\end_layout

\begin_layout Standard
Da im Fall von TUInventory nicht gewünscht ist, dass Daten direkt im Baum
 geändert werden können und die Darstellung der Daten nur an dieser Stelle
 erfolgt, musste aufgrund von Kosten-Nutzen-Aspekten vorerst die Item-basierte
 Variante des 
\emph on
QTreeWidget
\emph default
 vorgezogen werden.
 Das Befüllen dieses Widgets erfolgt in der Methode 
\emph on
set_tree
\emph default
 der Klasse 
\emph on
MainDialog
\emph default
.
\end_layout

\begin_layout Standard
Zu Beginn wird hier über den bereits erläuterten Session-Context-Manager
 eine neue Datenbank-Session geöffnet, in der wir nun alle 
\emph on
Responsibilit
\emph default
ies abfragen können.
 Über diese wird nun iteriert, wobei in jeder Iteration für Ort, Benutzer
 und Gerät jeweils zuerst ein 
\emph on
QTreeWidgetItem
\emph default
 erzeugt wird.
 Dieses wird zum Einfügen in den Baum benötigt.
 Nun wird nach einem Siebprinzip nacheinander ermittelt, ob sich der Ort,
 Benutzer und das Gerät bereits im Baum befinden.
 Hierbei wird zuerst überprüft, ob sich im Wurzelverzeichnis 
\emph on
root
\emph default
 des Baums die 
\emph on
Location
\emph default
 der aktuellen 
\emph on
Responsibility
\emph default
 befindet.
 Sofern dies nicht der Fall ist, wird die Location mit all ihren untergeordneten
 Elementen eingefügt.
 Falls sich die 
\emph on
Location
\emph default
 bereits als sog.
 
\emph on
TopLevelItem
\emph default
 im Baum befindet, wird überprüft, ob sich unter dieser 
\emph on
Location
\emph default
 bereits der 
\emph on
User
\emph default
 der aktuellen 
\emph on
Responsibility
\emph default
 befindet.
 Sofern dies nicht der Fall ist, wird der 
\emph on
User
\emph default
 unter seiner 
\emph on
Location
\emph default
 einsortiert und bekommt das aktuelle 
\emph on
Device
\emph default
 als Unterelement zugewiesen.
 Sollte der 
\emph on
User
\emph default
 bereits vorhanden sein, wird analog zur 
\emph on
Location
\emph default
 weiterverfahren.
 Dieser Prozess ist im folgenden Struktogramm dargestellt:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/Responsibility-Baum-Sieb-Struktorgramm.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Struktogramm nach Nassi-Shneiderman zum Responsibility-Baum-Sieb 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In diesem Teil des Programms werden oftmals Generator-Expressions und List-Compr
ehensions verwendet, daher sei im Folgenden kurz erläutert, wann man sich
 für welche entscheidet.
\end_layout

\begin_layout Standard
Der folgende Programmausschnitt zeigt einen Ausschnitt der interaktiven
 Konsole.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/Generator-Expression_vs_List-Comprehension.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gegenüberstellung Generator Expression und List Comprehension
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zu Beginn wird hier die Funktion 
\emph on
getsizeof
\emph default
 des Moduls 
\emph on
sys
\emph default
 der Standardlibrary importiert, die es erlaubt, die Größe einer Instanz
 in Bytes zu ermitteln.
 Nun wird zunächst über eine List-Comprehension eine Liste mit den Zahlen
 0 bis 9 definiert.
 Anschließend werden dieselben Zahlen mit einer Generator-Expression hinterlegt.
 
\end_layout

\begin_layout Standard
Vergleicht man hier die Größe der beiden Instanzen, wird klar, dass die
 Generator-Expression wesentlich kleiner ist.
 Führt man nun einen Typvergleich der Instanzen durch, sieht man, dass es
 sich bei 
\emph on
a
\emph default
 um eine Liste und bei 
\emph on
b
\emph default
 um einen Generator handelt.
 Damit lässt sich auch einfach der geringere Speicher-Footprint erklären:
 Bei einer List-Comprehension erfolgt die Auswertung sofort und somit liegt
 die ganze Liste im Speicher.
 Bei der Generator-Expression hingegen wird erst zum Zeitpunkt der Auswertung
 die Methode 
\emph on
__next__
\emph default
 der zugrundeliegenden Generatorinstanz aufgerufen, welche dann intern mittels
 
\emph on
yield
\emph default
 den nächsten Wert ausgibt.
\end_layout

\begin_layout Standard
Jedoch kann man nicht immer Generatoren einsetzen, da diese einige entscheidende
 Nachteile haben.
 So ist es nicht möglich, mittels Index auf die Elemente eines Generators
 zuzugreifen.
 Außerdem ist ein Generator nach einer 
\begin_inset Quotes eld
\end_inset

Benutzung
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

aufgebraucht
\begin_inset Quotes erd
\end_inset

.
 Dies kann man sehen, wenn man zweimal die Summen unserer beiden Instanzen
 addiert.
 Für die List-Comprehension wird hier korrekterweise 90 ausgegeben  (
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum_{n=0}^{9} n = 45$
\end_layout

\end_inset

), für die Generator-Expression jedoch nur 45, da sie beim zweiten Aufruf
 0 zurückgibt.
 Hierzu sollte noch gesagt werden, dass, wenn man einen Generator nicht
 über eine Generator-Expression, sondern manuell als Klasse/Funktion implementie
rt, dies teilweise umgangen werden kann.
\end_layout

\begin_layout Standard
Mit diesem Wissen ist nun auch leicht erklärbar, wann welche der Strukturen
 eingesetzt wurde:
\end_layout

\begin_layout Itemize
Generator-Expression immer, wenn sichergestellt ist, dass die Instanz nur
 einmal iteriert werden muss.
\end_layout

\begin_layout Itemize
List-Comprehension immer dann, wenn die Instanz mehrfach iteriert oder subscribe
d (dt.
 abonniert - also die [Index]-Notation) werden muss
\end_layout

\begin_layout Standard
Im Zuge des Refactoring wird auch hier nachgebessert.
 Der Filtervorgang wird von 
\begin_inset Quotes gld
\end_inset

Pure Python
\begin_inset Quotes grd
\end_inset

 zu SQL verlegt, wodurch wir uns höhere Performanz versprechen.
 Wie bei allen anderen Abfragen, werden auch hier die Abfragen nicht über
 SQL direkt, sondern über die Objektorientierte Query-API von SQLAlchemy
 durchgeführt.
 Da der Baum vom Nutzer direkt einsehbar ist und die Abfrage-Texte vom Nutzer
 beeinflusst werden können, wäre an dieser Stelle die Gefahr für SQL Injection
 mittels Interpolation der Namen in die Abfragebefehle groß.
\end_layout

\begin_layout Standard
Dem geänderten Arbeitsprinzip nach, werden zunächst alle 
\emph on
Locations
\emph default
 aus der Datenbank abgefragt; hier findet auch direkt eine alphabetische
 Sortierung statt.
 Nun wird für jede Location überprüft, ob es Responsibilities in der Datenbank
 gibt, über einen 
\emph on
join
\emph default
 (ORM-Methode für einen 
\emph on
Inner Join
\emph default
) werden die dazugehörigen Nutzer abgefragt.
 Nachdem auch die Nutzer alphabetisch sortiert sind, wird über diese iteriert
 und über eine weitere Abfrage ermittelt, welche Geräte der aktuellen Location
 und dem aktuellen User zuzuordnen sind.
 Diese geänderte Version hat außerdem den Vorteil, dass weniger Interaktion
 mit PyQt nötig ist.
 Es werden lediglich die entsprechenden 
\emph on
Items
\emph default
 zu jeder Location, jedem User und jedem Gerät jeweils exakt 1 mal erstellt
 und an der korrekten Stelle in den Baum eingepflegt.
 Abfragen aus dem Baum entfallen vollständig.
\end_layout

\begin_layout Subsection
Fazit
\end_layout

\begin_layout Standard
Es kann gesagt werden, dass PyQt (5) gegenüber anderen GUI-Paketen, wie
 z.B.
 tkinter aus der Python Standardbibliothek, klare Vorzüge hat.
 So ist der Code plattformunabhängig, die Bedienelemente sehen ansprechend
 aus und es ist einfach, auch größere Anwendungen noch gut zu strukturieren.
 Jedoch muss auch gesagt werden, dass PyQt5 teils nicht wirklich 
\begin_inset Quotes eld
\end_inset

pythonic
\begin_inset Quotes erd
\end_inset

 ist; so werden z.B.
 die Texte vieler Bedienelemente nicht über eine 
\emph on
property
\emph default
/Zuweisung sondern über eine 
\emph on
setText
\emph default
-Methode geändert.
 Da Qt eigentlich aus dem C++ Bereich kommt, ist dies verständlich, hätte
 im Wrapper jedoch eventuell geändert werden sollen.
\end_layout

\begin_layout Section
Optimierung
\end_layout

\begin_layout Standard
Nachdem das Backend vollständig implementiert und größtenteils verknüpft
 ist, wird nach potentiellen Optimierungsstellen gesucht.
 Hierzu wird das Modul 
\emph on
cProfile
\emph default
 eingesetzt.
\end_layout

\begin_layout Subsection
mouseMoveEvent
\end_layout

\begin_layout Standard
Beim Betrachten der Zeiten und Aufrufhäufigkeiten nach einer 
\begin_inset Quotes gld
\end_inset

Session
\begin_inset Quotes grd
\end_inset

 des Programms kann man z.B.
 sehen, dass sehr häufig das 
\emph on
mouseMoveEvent
\emph default
 des Hauptfensters aufgerufen wird.
 Diese Aufrufhäufigkeit lässt sich nicht optimieren
\begin_inset Foot
status open

\begin_layout Plain Layout
Außer durch ein anderes Event, wie z.B.
 Überprüfung, ob der Nutzer noch aktiv die UI bedient und Elemente anklickt
\end_layout

\end_inset

, da das Event genutzt wird, um zu überprüfen, ob der Nutzer noch aktiv
 ist oder eventuell ausgeloggt werden sollte.
 Der Code, der dies übernimmt, ist sehr klein und nimmt auch nach einer
 mehrminütigen Session nur einige Millisekunden in Anspruch, dennoch wird
 hier eine Optimierung angestrebt.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/Timeout-reset_1.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ursprünglicher Timeout reset
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird zu jedem 
\emph on
mouseMoveEvent
\emph default
 überprüft, ob aktuell ein Timer aktiv ist.
 Wenn dies der Fall ist, wird er zurückgesetzt.
 Diese Überprüfung ist notwendig, da andernfalls eine Exception geworfen
 wird, wenn die Klasse aktuell keine Instanz besitzt, die über die Methode
 
\emph on
reset 
\emph default
verfügt.
 Außerdem ist ein Beispiel des Dictionaries einer 
\emph on
MainDialog-Instanz
\emph default
 abgebildet, wie es zum Zeitpunkt eines 
\emph on
mouseMoveEvents
\emph default
 aussehen könnte.
 Wie zu sehen ist, ist dieses Dictionary nicht unbedeutend klein  (ca.
 100 Elemente) was jedoch kein Problem darstellt, da ein Dictionary-Lookup
 i.d.R.
 eine Zeitkomplexität von O(1)  (im worst case O(n), bei vielen Hash-Kollisionen
 etc.) besitzt.
 Dennoch gibt es hier eventuell eine effizientere Variante: die Funktion
 
\emph on
hasattr
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/Timeout-reset_2.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Alternativer Timeout reset
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ein Blick in den Python Sourcecode zeigt, dass diese in C implementiert
 ist
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/python/cpython/blob/master/Python/bltinmodule.c
\end_layout

\end_inset

, was einen Geschwindigkeitsschub in Aussicht stellt.
 Dies wird jedoch dadurch relativiert, dass auch Dictionaries in C implementiert
 sind
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/python/cpython/blob/master/Objects/dictobject.c
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Daher wird ein statistischer Versuch herangezogen, um zu sehen, ob eine
 Variante schneller ist als die andere:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/hasattr_vs_dict-lookup_cropped.png
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Vergleich von dict lookup und hasattr  (jeweiliger Durchschnitt der Versuchsreih
e in Legende)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da hier zu sehen ist, dass beide Varianten praktisch gleich sind, könnte
 man hier bereits eine Entscheidung treffen, es wird jedoch noch das letzte
 Werkzeug herangezogen, um die Varianten zu vergleichen: Bytecode
\end_layout

\begin_layout Standard
Wie eingangs erwähnt wurde, ist Bytecode das Zwischenkompilat, welches tatsächli
ch vom Interpreter verwertet wird.
 Zugriff auf den Bytecode bekommt man entweder über das 
\emph on
__pycache__
\emph default
 oder den 
\emph on
__code__
\emph default
 Member.
\end_layout

\begin_layout Standard
Das Modul 
\emph on
dis
\emph default
 erlaubt es, diesen Bytecode in menschenlesbarer Form darzustellen.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/hasattr_vs_dict-lookup_2.py"
lstparams "language=Python,numbers=left"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bytecode zu beiden Varianten erzeugen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/hasattr_vs_dict-lookup_2_output.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bytecode zu beiden Varianten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bytecode liest sich wie folgt (Spalten von links nach rechts aufsteigend
 nummeriert)
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
after "24.12.18 - 20:27 Uhr"
key "dis"
literal "false"

\end_inset


\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
Zeilennummer des Quellcodes
\end_layout

\begin_layout Enumerate
Hier nicht vorhanden  (Aktuelle Anweisung beim schrittweisen Ausführen)
\end_layout

\begin_layout Enumerate
Mögliches Sprungziel markiert mit >>
\end_layout

\begin_layout Enumerate
Adresse der Anweisung
\end_layout

\begin_layout Enumerate
Anweisungsname
\end_layout

\begin_layout Enumerate
Anweisungsparameter
\end_layout

\begin_layout Enumerate
Interpretation der Parameter in Klammern
\end_layout

\begin_layout Standard
Um den Sprung in beiden Varianten direkt zu Anfang zu erklären: Wenn das
 
\emph on
if
\emph default
 als 
\emph on
False
\emph default
 evaluiert, gibt die Funktion ein 
\emph on
None
\emph default
 zurück.
\end_layout

\begin_layout Standard
Ebenso können vorab die Zeilen 30 und 35 erklärt und gleichzeitig eine Einführun
g in Bytecode gegeben werden
\begin_inset Foot
status open

\begin_layout Plain Layout
Einige Aspekte sind hier zum besseren Verständnis vereinfacht dargestellt
  (z.B.
 werden eigentlich 
\emph on
frame
\emph default
-Objekte auf die Stacks gelegt)
\end_layout

\end_inset

, da sie bei beiden gleich sind:
\end_layout

\begin_layout Itemize
Es wird zuerst die Globale 
\emph on
a
\emph default
 auf den 
\emph on
Evaluation-Stack
\emph default
  (im Folgenden E-Stack)
\emph on
 
\emph default
geladen.
\end_layout

\begin_layout Itemize
Anschließend wird das TOS (Top of Stack)-Element, also 
\emph on
a
\emph default
, mit der Anweisung 
\emph on
getattr (TOS, co_names[namei]) -> getattr (a, co_names[timeout])
\emph default
 ersetzt.
\end_layout

\begin_layout Itemize
Dasselbe geschieht nun mit 
\emph on
reset.
\end_layout

\begin_layout Itemize
Nun liegt 
\emph on
reset
\emph default
 oben auf dem E-Stack und wird mit 0 positionellen Argumenten aufgerufen,
 der Rückgabewert wird auf den E-Stack gepusht.
\end_layout

\begin_layout Itemize
Die folgende Anweisung gibt an, dass der Rückgabewert nicht weiter verwertet
 und somit verworfen wird.
\end_layout

\begin_layout Itemize
Die letzen beiden Zeilen sind die bereits erklärten Anweisungen des impliziten
 Funktions-return.
\end_layout

\begin_layout Standard
Die Abfolge für hasattr ist wie folgt  (Alle Ladeanweisungen erfolgen auf
 den E-Stack):
\end_layout

\begin_layout Itemize
Laden der Globalen 
\emph on
hasattr
\end_layout

\begin_layout Itemize
Laden der Globalen 
\emph on
a
\end_layout

\begin_layout Itemize
Laden der Konstante 
\emph on
'timeout'
\end_layout

\begin_layout Itemize
Aufruf einer Funktion mit zwei positionellen Argumenten, dies ist der Aufruf
 von 
\emph on
hasattr
\emph default
 mit 
\emph on
a
\emph default
 und 
\emph on
'timeout'
\end_layout

\begin_layout Itemize
Hier folgt der Sprung falls das TOS-Element 
\emph on
False
\emph default
 ist.
\end_layout

\begin_layout Standard
Wohingegen die Abfolge für den 
\emph on
dict-lookup
\emph default
 ist:
\end_layout

\begin_layout Itemize
Laden der Konstante 
\emph on
'timeout'
\end_layout

\begin_layout Itemize
Laden Globale 
\emph on
a
\end_layout

\begin_layout Itemize
Laden des Attributs 
\emph on
__dict__
\emph default
 von 
\emph on
a
\end_layout

\begin_layout Itemize
Vergleichsoperation 
\emph on
in
\emph default
 auf 
\emph on
__dict__
\emph default
 und 
\emph on
'timeout'
\end_layout

\begin_layout Itemize
Hier folgt der Sprung falls das TOS-Element 
\emph on
False
\emph default
 ist.
\end_layout

\begin_layout Standard
Der Unterschied besteht also darin, dass eimal eine Globale mehr geladen
 wird  (globale Lookups können kostspielige Operationen sein) und ein Funktionsa
ufruf  (generell auch eher kostspielig) stattfindet, wohingegen beim Anderen
 mal ein Attribut abgerufen wird und eine Vergleichsoperation stattfindet.
 Sieht man sich die Implementierung des Interpreters an
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/python/cpython/blob/master/Python/ceval.c, 24.12.18 - 21:14
 Uhr
\end_layout

\end_inset

, sieht man, dass beide Varianten mittels Branch-Prediction optimiert werden.
 In diesem konkreten Fall wird auch durch den Bytecode nicht klar, dass
 eine Variante generell schneller ist als eine andere  (was durch die Messung
 unterstützt wird).
\end_layout

\begin_layout Standard
Schließlich kann hier keine Optimierung erfolgen, dennoch wird der Code
 dahingehend abgeändert, dass er 
\emph on
hasattr
\emph default
 einsetzt, da dies die leichter zu lesende und somit schlicht bessere Variante
 ist.
\end_layout

\begin_layout Subsection
ContextSession Cache Refresh
\end_layout

\begin_layout Standard
In der Magic Method 
\emph on
__exit__
\emph default
 der ContextSession Klasse, ist es erforderlich auf jedes Objekt einer Liste
 eine Funktion anzuwenden.
 Klassischerweise würde man hier auf eine 
\emph on
for
\emph default
 Schleife zurückgreifen, doch Python bietet noch andere Lösungsmöglichkeiten.
 Grundsätzlich sagt man in Python, dass List Comprehensions oftmals schneller
 als for-Schleifen sind, da sie auf optimierte Bytecode Operationen zurückgreife
n können.
 Jedoch bezieht sich das stets auf Anwendungen in denen eine neue Liste
 erzeugt wird.
 Eine Anwendung wie unsere, bei der lediglich die Seiteneffekte der Schleife
 gewünscht sind, und keine neue Liste benötigt wird, wie eine List Comprehension
 sie erzeugt sind jedoch nichts was man in Python häufig antrifft, bzw.
 was i.d.R.
 mit einer Comprehension gelöst wird.
 Desweiteren gibt es noch die Funktion 
\emph on
map
\emph default
 welche ebenfalls auf jedes Element eines iterierbaren Objektes eine Funktion
 anwendet.
 Auch hier wurde ein Vergleich über einer einfachen Grundfunktion nach dem
 bereits bekannten Verfahren durchgeführt.
 Die interessanten Funktionen sind 
\emph on
f_1
\emph default
, 
\emph on
f_2
\emph default
 und 
\emph on
f_3
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/map_vs_for_vs_listcomp_side_effects.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Analysecode
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Beispiel wird hier für jedes Element einer Liste (die Liste beinhaltet
 alle ASCII Buchstaben) eine Funktion aufgerufen, die dieses Element printed.
 Dabei erfolgt das printen jedoch nicht auf den Standartausgabestream 
\emph on
stdout
\emph default
, den 
\emph on
print
\emph default
 regulär nutzt, sondern in eine temporäre Datei.
 Führt man diesen Code aus ergibt sich folgende Ausgabe:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "Beispielprogramme/map_vs_for_vs_listcomp_side_effects_output.py"
lstparams "language=Python"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausschnitt der Konsolenausgabe
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Bilder/map_vs_for_vs_listcomp_side_effects_cropped.png
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisierung einer Testreihe
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Konsolenausgabe stellt dabei eine bestimmte Anzahl an Datensätzen dar,
 in denen jeweils 2000 mal der Funktionsaufruf durchgeführt und der jeweilige
 Durchschnitt der verschiedenen Methoden bestimmt wird.
 Die letzte Zeile jedes Datensatzes gibt die je schnellste Methode an.
\end_layout

\begin_layout Standard
Wie zu sehen ist, besteht beim Verzicht auf den Rückgabewert effektiv kein
 Unterschied zwischen List Comprehensions und for-Schleifen.
 Außerdem sieht man, dass 
\emph on
map
\emph default
 für solche Anwendungen wesentlich effizienter arbeitet, so ist es um einige
 Größenordnungen schneller als die beiden anderen Lösungen.
 Dementsprechend wird die ursprüngliche Implementierung durch eine auf 
\emph on
map
\emph default
 basierende ersetzt.
 Die optimierte Version läuft damit 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
approx 250$
\end_layout

\end_inset

 mal schneller.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Literaturverzeichnis"
options "alphadin"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{numbers=left, numberblanklines=true}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pläne
\end_layout

\begin_layout Subsection
Stromlaufplan
\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename Pläne/Stromlaufplan.pdf
	extra LaTeX "pages=-"
	rotateAngle 90

\end_inset


\end_layout

\begin_layout Subsection
Netzwerkplan
\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename Pläne/Netzwerkplan.pdf
	extra LaTeX "pages=-"
	rotateAngle 90

\end_inset


\end_layout

\begin_layout Subsection
Netzwerkplan nach EN81346
\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename Pläne/Netzwerkplan.pdf
	extra LaTeX "pages=-"
	rotateAngle 90

\end_inset


\end_layout

\begin_layout Section
Quellcode
\end_layout

\begin_layout Subsection
barcodereader.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../barcodereader.py"

\end_inset


\end_layout

\begin_layout Subsection
classes.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../classes.py"

\end_inset


\end_layout

\begin_layout Subsection
keys.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../keys.py"

\end_inset


\end_layout

\begin_layout Subsection
logger.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../logger.py"

\end_inset


\end_layout

\begin_layout Subsection
main.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../main.py"

\end_inset


\end_layout

\begin_layout Subsection
pydoc.sh
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../pydoc.sh"
lstparams "language=bash"

\end_inset


\end_layout

\begin_layout Subsection
qr_generator.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../qr_generator.py"

\end_inset


\end_layout

\begin_layout Subsection
slots.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../slots.py"

\end_inset


\end_layout

\begin_layout Subsection
ui.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../ui.py"

\end_inset


\end_layout

\begin_layout Subsection
utils.py
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../utils.py"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Automatisch generierte Dokumentation
\end_layout

\begin_layout Standard
Als .html auf beiliegendem USB-Stick, alternativ über pydoc.sh aus dem Quellcode
 zu generieren.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Genutzte Hilfsmittel
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Eidesstattliche Erklärung
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{gobble} % disable page numbering
\change_inserted 274824651 1551459897

\end_layout

\begin_layout Plain Layout

\change_inserted 274824651 1551459900


\backslash
noindent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 10page%
\end_inset


\end_layout

\begin_layout Standard
Ich erkläre hiermit an Eides statt, dass ich die vorliegende Arbeit selbständig
 verfasst und dabei keine anderen als die angegebenen Hilfsmittel benutzt
 habe.
 Sämtliche Zitate wurden gemäß dem 
\begin_inset Quotes gld
\end_inset

Leitfaden für die Durchführung und Gestaltung der Technikerarbeit
\begin_inset Quotes grd
\end_inset

 der Franz-Oberthür-Schule Würzburg als solche gekennzeichnet.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$ 
\backslash
Huge{
\backslash
frac{}{Unterschrift:
\backslash
;  Stefan
\backslash
: Volz}}$$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$ 
\backslash
Huge{
\backslash
frac{}{Datum}}$$
\end_layout

\end_inset


\begin_inset VSpace 10page%
\end_inset


\end_layout

\begin_layout Standard
Ich erkläre hiermit an Eides statt, dass ich die vorliegende Arbeit selbständig
 verfasst und dabei keine anderen als die angegebenen Hilfsmittel benutzt
 habe.
 Sämtliche Zitate wurden gemäß dem 
\begin_inset Quotes gld
\end_inset

Leitfaden für die Durchführung und Gestaltung der Technikerarbeit
\begin_inset Quotes grd
\end_inset

 der Franz-Oberthür-Schule Würzburg als solche gekennzeichnet.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$ 
\backslash
Huge{
\backslash
frac{}{Unterschrift:
\backslash
;  Yannis
\backslash
: K
\backslash
ddot{o}hler}}$$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$$ 
\backslash
Huge{
\backslash
frac{}{Datum}}$$
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\align center

\end_layout

\end_body
\end_document
